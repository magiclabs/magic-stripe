/* eslint-disable no-underscore-dangle */
import { __extends, __read, __spread } from "tslib";
import { createJsonRpcRequestPayload, standardizeJsonRpcRequestPayload } from '../core/json-rpc';
import { BaseModule } from './base-module';
import { createExtensionNotInitializedError, MagicExtensionError, MagicExtensionWarning } from '../core/sdk-exceptions';
import { createPromiEvent, encodeJSON, decodeJSON, storage, isPromiEvent } from '../util';
var sdkAccessFields = ['request', 'transport', 'overlay', 'sdk'];
/**
 * From the `BaseExtension`-derived instance, get the prototype
 * chain up to and including the `BaseModule` class.
 */
function getPrototypeChain(instance) {
    var currentProto = Object.getPrototypeOf(instance);
    var protos = [currentProto];
    while (currentProto !== BaseModule.prototype) {
        currentProto = Object.getPrototypeOf(currentProto);
        protos.push(currentProto);
    }
    return protos;
}
var BaseExtension = /** @class */ (function (_super) {
    __extends(BaseExtension, _super);
    function BaseExtension() {
        var _this = _super.call(this, undefined) || this;
        _this.__sdk_access_field_descriptors__ = new Map();
        _this.__is_initialized__ = false;
        _this.utils = {
            createPromiEvent: createPromiEvent,
            isPromiEvent: isPromiEvent,
            encodeJSON: encodeJSON,
            decodeJSON: decodeJSON,
            createJsonRpcRequestPayload: createJsonRpcRequestPayload,
            standardizeJsonRpcRequestPayload: standardizeJsonRpcRequestPayload,
            storage: storage,
        };
        // Disallow SDK access before initialization...
        var allSources = __spread([_this], getPrototypeChain(_this));
        sdkAccessFields.forEach(function (prop) {
            var allDescriptors = allSources.map(function (source) { return Object.getOwnPropertyDescriptor(source, prop); });
            var sourceIndex = allDescriptors.findIndex(function (x) { return !!x; });
            var isPrototypeField = sourceIndex > 0;
            var descriptor = allDescriptors[sourceIndex];
            /* istanbul ignore else */
            if (descriptor) {
                _this.__sdk_access_field_descriptors__.set(prop, { descriptor: descriptor, isPrototypeField: isPrototypeField });
                Object.defineProperty(_this, prop, {
                    configurable: true,
                    get: function () {
                        throw createExtensionNotInitializedError(prop);
                    },
                });
            }
        });
        return _this;
    }
    /**
     * Registers a Magic SDK instance with this Extension.
     *
     * @internal
     */
    BaseExtension.prototype.init = function (sdk) {
        var _this = this;
        if (this.__is_initialized__)
            return;
        // Replace original property descriptors
        // for SDK access fields post-initialization.
        sdkAccessFields.forEach(function (prop) {
            /* istanbul ignore else */
            if (_this.__sdk_access_field_descriptors__.has(prop)) {
                var _a = _this.__sdk_access_field_descriptors__.get(prop), descriptor = _a.descriptor, isPrototypeField = _a.isPrototypeField;
                if (isPrototypeField) {
                    // For prototype fields, we just need the `delete` operator so that
                    // the instance will fallback to the prototype chain itself.
                    delete _this[prop];
                }
                else {
                    Object.defineProperty(_this, prop, descriptor);
                }
            }
        });
        this.sdk = sdk;
        this.__is_initialized__ = true;
    };
    /**
     * Creates a deprecation warning wrapped with a native Magic SDK warning type.
     * Best practice is to warn users of upcoming deprecations at least one major
     * version before the change is implemented. You can use this method to
     * communicate deprecations in a manner consistent with Magic SDK core code.
     */
    BaseExtension.prototype.createDeprecationWarning = function (options) {
        var method = options.method, removalVersion = options.removalVersion, useInstead = options.useInstead;
        var useInsteadSuffix = useInstead ? " Use `" + useInstead + "` instead." : '';
        var message = "`" + method + "` will be removed from this Extension in version `" + removalVersion + "`." + useInsteadSuffix;
        return new MagicExtensionWarning(this, 'DEPRECATION_NOTICE', message);
    };
    /**
     * Creates a warning wrapped with a native Magic SDK warning type. This
     * maintains consistency in warning messaging for consumers of Magic SDK and
     * this Extension.
     */
    BaseExtension.prototype.createWarning = function (code, message) {
        return new MagicExtensionWarning(this, code, message);
    };
    /**
     * Creates an error wrapped with a native Magic SDK error type. This maintains
     * consistency in error handling for consumers of Magic SDK and this
     * Extension.
     */
    BaseExtension.prototype.createError = function (code, message, data) {
        return new MagicExtensionError(this, code, message, data);
    };
    return BaseExtension;
}(BaseModule));
var InternalExtension = /** @class */ (function (_super) {
    __extends(InternalExtension, _super);
    function InternalExtension() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InternalExtension;
}(BaseExtension));
/**
 * A base class representing "extensions" to the core Magic JS APIs. Extensions
 * enable new functionality by composing Magic endpoints methods together.
 */
var Extension = /** @class */ (function (_super) {
    __extends(Extension, _super);
    function Extension() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This is a special constructor used to mark "official" extensions. These
     * extensions are designed for special interaction with the Magic iframe using
     * custom JSON RPC methods, business logic, and global configurations. This is
     * intended for internal-use only (and provides no useful advantage to
     * open-source extension developers over the regular `Extension` class).
     *
     * @internal
     */
    Extension.Internal = InternalExtension;
    return Extension;
}(BaseExtension));
export { Extension };
//# sourceMappingURL=base-extension.js.map