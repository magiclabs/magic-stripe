import { __extends } from "tslib";
import { RPCErrorCode, SDKErrorCode, SDKWarningCode } from '@magic-sdk/types';
import { isJsonRpcErrorCode } from '../util/type-guards';
import { SDKEnvironment } from './sdk-environment';
// --- Error/warning classes
/**
 * This error type represents internal SDK errors. This could be developer
 * mistakes (or Magic's mistakes), or execution errors unrelated to standard
 * JavaScript exceptions.
 */
var MagicSDKError = /** @class */ (function (_super) {
    __extends(MagicSDKError, _super);
    function MagicSDKError(code, rawMessage) {
        var _this = _super.call(this, "Magic SDK Error: [" + code + "] " + rawMessage) || this;
        _this.code = code;
        _this.rawMessage = rawMessage;
        _this.__proto__ = Error;
        Object.setPrototypeOf(_this, MagicSDKError.prototype);
        return _this;
    }
    return MagicSDKError;
}(Error));
export { MagicSDKError };
/**
 * This error type communicates exceptions that occur during execution in the
 * Magic `<iframe>` context.
 */
var MagicRPCError = /** @class */ (function (_super) {
    __extends(MagicRPCError, _super);
    function MagicRPCError(sourceError) {
        var _this = _super.call(this) || this;
        _this.__proto__ = Error;
        var codeNormalized = Number(sourceError === null || sourceError === void 0 ? void 0 : sourceError.code);
        _this.rawMessage = (sourceError === null || sourceError === void 0 ? void 0 : sourceError.message) || 'Internal error';
        _this.code = isJsonRpcErrorCode(codeNormalized) ? codeNormalized : RPCErrorCode.InternalError;
        _this.message = "Magic RPC Error: [" + _this.code + "] " + _this.rawMessage;
        Object.setPrototypeOf(_this, MagicRPCError.prototype);
        return _this;
    }
    return MagicRPCError;
}(Error));
export { MagicRPCError };
/**
 * In contrast to `SDKError` objects, this "warning" type communicates important
 * context that does not rise to the level of an exception. These should be
 * logged rather than thrown.
 */
var MagicSDKWarning = /** @class */ (function () {
    function MagicSDKWarning(code, rawMessage) {
        this.code = code;
        this.rawMessage = rawMessage;
        this.message = "Magic SDK Warning: [" + code + "] " + rawMessage;
    }
    /**
     * Logs this warning to the console.
     */
    MagicSDKWarning.prototype.log = function () {
        console.warn(this.message);
    };
    return MagicSDKWarning;
}());
export { MagicSDKWarning };
/**
 * This error type is reserved for communicating errors that arise during
 * execution of Magic SDK Extension methods. Compare this to the `SDKError`
 * type, specifically in context of Extensions.
 */
var MagicExtensionError = /** @class */ (function (_super) {
    __extends(MagicExtensionError, _super);
    function MagicExtensionError(ext, code, rawMessage, data) {
        var _this = _super.call(this, "Magic Extension Error (" + ext.name + "): [" + code + "] " + rawMessage) || this;
        _this.code = code;
        _this.rawMessage = rawMessage;
        _this.data = data;
        _this.__proto__ = Error;
        Object.setPrototypeOf(_this, MagicExtensionError.prototype);
        return _this;
    }
    return MagicExtensionError;
}(Error));
export { MagicExtensionError };
/**
 * In contrast to `MagicExtensionError` objects, this "warning" type
 * communicates important context that does not rise to the level of an
 * exception. These should be logged rather than thrown.
 */
var MagicExtensionWarning = /** @class */ (function () {
    function MagicExtensionWarning(ext, code, rawMessage) {
        this.code = code;
        this.rawMessage = rawMessage;
        this.message = "Magic Extension Warning (" + ext.name + "): [" + code + "] " + rawMessage;
    }
    /**
     * Logs this warning to the console.
     */
    MagicExtensionWarning.prototype.log = function () {
        console.warn(this.message);
    };
    return MagicExtensionWarning;
}());
export { MagicExtensionWarning };
// --- SDK error factories
export function createMissingApiKeyError() {
    return new MagicSDKError(SDKErrorCode.MissingApiKey, 'Please provide an API key that you acquired from the Magic developer dashboard.');
}
export function createModalNotReadyError() {
    return new MagicSDKError(SDKErrorCode.ModalNotReady, 'Modal is not ready.');
}
export function createMalformedResponseError() {
    return new MagicSDKError(SDKErrorCode.MalformedResponse, 'Response from the Magic iframe is malformed.');
}
export function createExtensionNotInitializedError(member) {
    return new MagicSDKError(SDKErrorCode.ExtensionNotInitialized, "Extensions must be initialized with a Magic SDK instance before `Extension." + member + "` can be accessed. Do not invoke `Extension." + member + "` inside an extension constructor.");
}
export function createIncompatibleExtensionsError(extensions) {
    var msg = "Some extensions are incompatible with `" + SDKEnvironment.sdkName + "@" + SDKEnvironment.version + "`:";
    extensions
        .filter(function (ext) { return typeof ext.compat !== 'undefined' && ext.compat !== null; })
        .forEach(function (ext) {
        var compat = ext.compat[SDKEnvironment.sdkName];
        /* istanbul ignore else */
        if (typeof compat === 'string') {
            msg += "\n  - Extension `" + ext.name + "` supports version(s) `" + compat + "`";
        }
        else if (!compat) {
            msg += "\n  - Extension `" + ext.name + "` does not support " + SDKEnvironment.platform + " environments.";
        }
        // Else case is irrelevant here here
        // (we filter out extensions with missing `compat` field)
    });
    return new MagicSDKError(SDKErrorCode.IncompatibleExtensions, msg);
}
export function createInvalidArgumentError(options) {
    /**
     * Parses the argument index (given by `argument`) to attach the correct ordinal suffix.
     * (i.e.: 1st, 2nd, 3rd, 4th, etc.)
     */
    var ordinalSuffix = function (i) {
        var iAdjusted = i + 1; // Argument is zero-indexed.
        var j = iAdjusted % 10;
        var k = iAdjusted % 100;
        if (j === 1 && k !== 11)
            return iAdjusted + "st";
        if (j === 2 && k !== 12)
            return iAdjusted + "nd";
        if (j === 3 && k !== 13)
            return iAdjusted + "rd";
        return iAdjusted + "th";
    };
    return new MagicSDKError(SDKErrorCode.InvalidArgument, "Invalid " + ordinalSuffix(options.argument) + " argument given to `" + options.procedure + "`.\n" +
        ("  Expected: `" + options.expected + "`\n") +
        ("  Received: `" + options.received + "`"));
}
// --- SDK warning factories
export function createDuplicateIframeWarning() {
    return new MagicSDKWarning(SDKWarningCode.DuplicateIframe, 'Duplicate iframes found.');
}
export function createSynchronousWeb3MethodWarning() {
    return new MagicSDKWarning(SDKWarningCode.SyncWeb3Method, 'Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.');
}
export function createReactNativeEndpointConfigurationWarning() {
    return new MagicSDKWarning(SDKWarningCode.ReactNativeEndpointConfiguration, "CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The `endpoint` parameter SHOULD NOT be provided. The Magic `<iframe>` is automatically wrapped by a WebView pointed at `" + SDKEnvironment.defaultEndpoint + "`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.");
}
export function createDeprecationWarning(options) {
    var method = options.method, removalVersions = options.removalVersions, useInstead = options.useInstead;
    var removalVersion = removalVersions[SDKEnvironment.sdkName];
    var useInsteadSuffix = useInstead ? " Use `" + useInstead + "` instead." : '';
    var message = "`" + method + "` will be removed from `" + SDKEnvironment.sdkName + "` in version `" + removalVersion + "`." + useInsteadSuffix;
    return new MagicSDKWarning(SDKWarningCode.DeprecationNotice, message);
}
//# sourceMappingURL=sdk-exceptions.js.map