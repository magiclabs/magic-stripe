import { __awaiter, __generator } from "tslib";
import { MagicIncomingWindowMessage, } from '@magic-sdk/types';
import { JsonRpcResponse } from './json-rpc';
import { createPromise } from '../util/promise-tools';
/**
 * Get the originating payload from a batch request using the specified `id`.
 */
function getRequestPayloadFromBatch(requestPayload, id) {
    return id && Array.isArray(requestPayload)
        ? requestPayload.find(function (p) { return p.id === id; })
        : requestPayload;
}
/**
 * Ensures the incoming response follows the expected schema and parses for a
 * JSON RPC payload ID.
 */
function standardizeResponse(requestPayload, event) {
    var _a;
    var id = (_a = event.data.response) === null || _a === void 0 ? void 0 : _a.id;
    var requestPayloadResolved = getRequestPayloadFromBatch(requestPayload, id);
    if (id && requestPayloadResolved) {
        // Build a standardized response object
        var response = new JsonRpcResponse(requestPayloadResolved)
            .applyResult(event.data.response.result)
            .applyError(event.data.response.error);
        return { id: id, response: response };
    }
    return {};
}
var PayloadTransport = /** @class */ (function () {
    /**
     * Create an instance of `PayloadTransport`
     *
     * @param endpoint - The URL for the relevant iframe context.
     * @param parameters - The unique, encoded query parameters for the
     * relevant iframe context.
     */
    function PayloadTransport(endpoint, parameters) {
        this.endpoint = endpoint;
        this.parameters = parameters;
        this.messageHandlers = new Set();
        this.init();
    }
    PayloadTransport.prototype.post = function (overlay, msgType, payload) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, createPromise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                        var batchData, batchIds, acknowledgeResponse, removeResponseListener;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, overlay.ready];
                                case 1:
                                    _a.sent();
                                    batchData = [];
                                    batchIds = Array.isArray(payload) ? payload.map(function (p) { return p.id; }) : [];
                                    return [4 /*yield*/, overlay.postMessage({ msgType: msgType + "-" + this.parameters, payload: payload })];
                                case 2:
                                    _a.sent();
                                    acknowledgeResponse = function (removeEventListener) { return function (event) {
                                        var _a = standardizeResponse(payload, event), id = _a.id, response = _a.response;
                                        if (id && response && Array.isArray(payload) && batchIds.includes(id)) {
                                            batchData.push(response);
                                            // For batch requests, we wait for all responses before resolving.
                                            if (batchData.length === payload.length) {
                                                removeEventListener();
                                                resolve(batchData);
                                            }
                                        }
                                        else if (id && response && !Array.isArray(payload) && id === payload.id) {
                                            removeEventListener();
                                            resolve(response);
                                        }
                                    }; };
                                    removeResponseListener = this.on(MagicIncomingWindowMessage.MAGIC_HANDLE_RESPONSE, acknowledgeResponse(function () { return removeResponseListener(); }));
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Listen for events received with the given `msgType`.
     *
     * @param msgType - The `msgType` encoded with the event data.
     * @param handler - A handler function to execute on each event received.
     * @return A `void` function to remove the attached event.
     */
    PayloadTransport.prototype.on = function (msgType, handler) {
        var _this = this;
        var boundHandler = handler.bind(window);
        // We cannot effectively cover this function because it never gets reference
        // by value. The functionality of this callback is tested within
        // `initMessageListener`.
        /* istanbul ignore next */
        var listener = function (event) {
            if (event.data.msgType === msgType + "-" + _this.parameters)
                boundHandler(event);
        };
        this.messageHandlers.add(listener);
        return function () { return _this.messageHandlers.delete(listener); };
    };
    return PayloadTransport;
}());
export { PayloadTransport };
//# sourceMappingURL=payload-transport.js.map