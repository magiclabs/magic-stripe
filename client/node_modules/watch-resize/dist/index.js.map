{"version":3,"file":"index.js","sources":["../src/lib.ts"],"sourcesContent":["/**\n * Payload received by a `ResizeHandler`.\n */\nexport interface ResizePayload<T extends HTMLElement> {\n  element: T;\n  event: UIEvent;\n  prevBoundingClientRect: ClientRect | DOMRect;\n  destroy: DestroyWatcher;\n}\n\n/**\n * A callback function invoked when the\n * watched element emits a \"resize\" event.\n */\nexport type ResizeHandler<T extends HTMLElement> = (payload: ResizePayload<T>) => void | Promise<void>;\n\n/**\n * A synchronous function to unobserve\n * the element given to `watchResize`.\n */\nexport type DestroyWatcher = () => void;\n\n/**\n * Checks if the given object is a valid `HTMLElement`.\n */\nfunction isElement(obj: any) {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return obj instanceof HTMLElement;\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return (\n      typeof obj === 'object' &&\n      obj.nodeType === 1 &&\n      typeof obj.style === 'object' &&\n      typeof obj.ownerDocument === 'object'\n    );\n  }\n}\n\n/**\n * Returns a Promise that resolves when the observer is mounted. The observer\n * fires \"resize\" events when the given DOM element's width or height changes.\n *\n * The resolved Promise value is a synchronous function which unobserves the\n * element when called.\n *\n * @param element - HTMLElement to observe.\n * @param handler - A callback function invoked whenever the given `element`\n * resizes.\n */\nexport function watchResize<T extends HTMLElement>(element: T, handler: ResizeHandler<T>): Promise<DestroyWatcher> {\n  return new Promise<DestroyWatcher>((resolve, reject) => {\n    // Assert that `element` is defined and is a valid DOM node.\n    if (typeof element === 'undefined' || element === null) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element must be defined.')));\n    }\n\n    if (!isElement(element)) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element is not a valid DOM node.')));\n    }\n\n    if (!element.parentNode) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element is not yet attached to the DOM.')));\n    }\n\n    // Ensure we are relatively positioned so that the nested browsing context\n    // is correctly sized and positioned.\n    if (getComputedStyle(element).position === 'static') {\n      element.style.position = 'relative';\n    }\n\n    // Create a nested browsing context using an <object> element.\n    const obj = document.createElement('object');\n\n    // Set type and data\n    obj.type = 'text/html';\n    obj.data = 'about:blank';\n\n    // Set CSSOM properties\n    obj.style.display = 'block';\n    obj.style.position = 'absolute';\n    obj.style.top = '0';\n    obj.style.left = '0';\n    obj.style.height = '100%';\n    obj.style.width = '100%';\n    obj.style.overflow = 'hidden';\n    obj.style.pointerEvents = 'none';\n    obj.style.zIndex = '-1';\n\n    // Save a reference to the element's current client rect.\n    let prevBoundingClientRect: ClientRect | DOMRect = element.getBoundingClientRect();\n\n    // When the <object> loads, apply the \"resize\" event listener and resolve.\n    obj.addEventListener('load', () => {\n      if (obj.contentDocument && obj.contentDocument.defaultView) {\n        const viewContext = obj.contentDocument.defaultView;\n\n        const listener = (event: UIEvent) => {\n          handler({ element, event, prevBoundingClientRect, destroy });\n          prevBoundingClientRect = element.getBoundingClientRect();\n        };\n\n        const destroy = () => {\n          viewContext.removeEventListener('resize', listener);\n          obj.remove();\n        };\n\n        viewContext.addEventListener('resize', listener);\n\n        resolve(destroy);\n      } else {\n        reject(new Error('[watch-resize] Failed to build a nested browsing context.'));\n      }\n    });\n\n    // Append the <object> to the target element.\n    element.appendChild(obj);\n  });\n}\n"],"names":["element","handler","Promise","resolve","reject","Error","obj","HTMLElement","e","nodeType","style","ownerDocument","isElement","parentNode","getComputedStyle","position","document","createElement","type","data","display","top","left","height","width","overflow","pointerEvents","zIndex","prevBoundingClientRect","getBoundingClientRect","addEventListener","contentDocument","defaultView","viewContext","listener","event","destroy","removeEventListener","remove","appendChild"],"mappings":"6BAqDmDA,EAAYC,GAC7D,WAAWC,QAAwB,SAACC,EAASC,GAE3C,GAAI,MAAOJ,EACT,OAAOI,EAAOF,QAAQE,OAAO,IAAIC,MAAM,uDAGzC,IAnCJ,SAAmBC,GACjB,IAEE,OAAOA,aAAeC,YACtB,MAAOC,GAIP,MACiB,iBAARF,GACU,IAAjBA,EAAIG,UACiB,iBAAdH,EAAII,OACkB,iBAAtBJ,EAAIK,eAuBRC,CAAUZ,GACb,OAAOI,EAAOF,QAAQE,OAAO,IAAIC,MAAM,+DAGzC,IAAKL,EAAQa,WACX,OAAOT,EAAOF,QAAQE,OAAO,IAAIC,MAAM,sEAKE,WAAvCS,iBAAiBd,GAASe,WAC5Bf,EAAQU,MAAMK,SAAW,YAI3B,IAAMT,EAAMU,SAASC,cAAc,UAGnCX,EAAIY,KAAO,YACXZ,EAAIa,KAAO,cAGXb,EAAII,MAAMU,QAAU,QACpBd,EAAII,MAAMK,SAAW,WACrBT,EAAII,MAAMW,IAAM,IAChBf,EAAII,MAAMY,KAAO,IACjBhB,EAAII,MAAMa,OAAS,OACnBjB,EAAII,MAAMc,MAAQ,OAClBlB,EAAII,MAAMe,SAAW,SACrBnB,EAAII,MAAMgB,cAAgB,OAC1BpB,EAAII,MAAMiB,OAAS,KAGnB,IAAIC,EAA+C5B,EAAQ6B,wBAG3DvB,EAAIwB,iBAAiB,OAAQ,WAC3B,GAAIxB,EAAIyB,iBAAmBzB,EAAIyB,gBAAgBC,YAAa,CAC1D,IAAMC,EAAc3B,EAAIyB,gBAAgBC,YAElCE,EAAW,SAACC,GAChBlC,EAAQ,CAAED,QAAAA,EAASmC,MAAAA,EAAOP,uBAAAA,EAAwBQ,QAAAA,IAClDR,EAAyB5B,EAAQ6B,yBAG7BO,EAAU,WACdH,EAAYI,oBAAoB,SAAUH,GAC1C5B,EAAIgC,UAGNL,EAAYH,iBAAiB,SAAUI,GAEvC/B,EAAQiC,QAERhC,EAAO,IAAIC,MAAM,gEAKrBL,EAAQuC,YAAYjC"}