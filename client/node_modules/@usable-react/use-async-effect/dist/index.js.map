{"version":3,"file":"index.js","sources":["../src/index.ts","../../use-is-mounted/dist/index.m.js"],"sourcesContent":["import { DependencyList, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { useIsMounted } from '@usable-react/use-is-mounted';\n\ntype NonVoid<T> = T extends void ? never : T;\n\ntype NarrowedAsyncEffect<TContext, TResult, TVisited extends string | void, TNarrow extends string> = Omit<\n  AsyncEffect<TContext, TResult, TVisited | TNarrow>,\n  NonVoid<TVisited> | TNarrow\n>;\n\ninterface AsyncEffect<TContext, TResult, TVisited extends string | void = void> {\n  /**\n   * Registers a callback to execute when the async handler resolves. Analagous\n   * to `Promise.then`.\n   */\n  fullfilled(\n    onfulfilled?: ((value: TResult, context: Partial<TContext>) => void) | null,\n  ): NarrowedAsyncEffect<TContext, TResult, TVisited, 'fullfilled'>;\n\n  /**\n   * Registers a callback to execute when the async handler rejects. Analagous\n   * to `Promise.catch`.\n   */\n  rejected(\n    onrejected?: ((reason: any, context: Partial<TContext>) => void) | null,\n  ): NarrowedAsyncEffect<TContext, TResult, TVisited, 'rejected'>;\n\n  /**\n   * Registers a callback to execute when the async handler completes, whether\n   * successfully or not. Analagous to `Promise.finally`.\n   */\n  settled(\n    onsettled?: ((context: Partial<TContext>) => void) | null,\n  ): NarrowedAsyncEffect<TContext, TResult, TVisited, 'settled'>;\n\n  /**\n   * Registers a callback to execute when the underlying `React.useEffect` is\n   * cleaned up.\n   */\n  cleanup(\n    onfulfilled?: ((context: Partial<TContext>) => void) | null,\n  ): NarrowedAsyncEffect<TContext, TResult, TVisited, 'cleanup'>;\n}\n\n/**\n * Makes asynchronous work inside the React lifecycle easy with automatic guards\n * against updating internal component state if the component is unmounted\n * before the async work is finished.\n */\nexport function useAsyncEffect<TContext extends { [key: string]: any } = { [key: string]: any }, TResult = any>(\n  handler: (context: Partial<TContext>) => Promise<TResult>,\n  deps?: DependencyList,\n): AsyncEffect<TContext, TResult> {\n  const thenCallback = useRef<any>();\n  const registerThenCb = useCallback(onfulfilled => {\n    thenCallback.current = onfulfilled;\n    return chain;\n  }, []);\n\n  const catchCallback = useRef<any>();\n  const registerCatchCb = useCallback(onrejected => {\n    catchCallback.current = onrejected;\n    return chain;\n  }, []);\n\n  const finallyCallback = useRef<any>();\n  const registerFinallyCb = useCallback(onsettled => {\n    finallyCallback.current = onsettled;\n    return chain;\n  }, []);\n\n  const cleanupCallback = useRef<any>();\n  const registerCleanupCb = useCallback(oncleanup => {\n    cleanupCallback.current = oncleanup;\n    return chain;\n  }, []);\n\n  const chain: any = useMemo(() => {\n    return {\n      fullfilled: registerThenCb,\n      rejected: registerCatchCb,\n      settled: registerFinallyCb,\n      cleanup: registerCleanupCb,\n    };\n  }, []);\n\n  const isMounted = useIsMounted();\n  useEffect(() => {\n    const context: any = {};\n\n    handler(context)\n      .then(value => {\n        if (isMounted() && thenCallback.current) thenCallback.current(value, context);\n      })\n      .catch(err => {\n        if (isMounted() && catchCallback.current) catchCallback.current(err, context);\n      })\n      .finally(() => {\n        if (isMounted() && finallyCallback.current) finallyCallback.current(context);\n      });\n\n    if (cleanupCallback.current) return () => cleanupCallback.current(context);\n    return undefined;\n  }, deps);\n\n  return chain;\n}\n","import{useRef as r,useEffect as n,useCallback as t}from\"react\";function u(){var u=r(!1);return n(function(){return u.current=!0,function(){u.current=!1}},[]),t(function(){return u.current},[])}export{u as useIsMounted};\n//# sourceMappingURL=index.m.js.map\n"],"names":["handler","deps","isMountedRef","thenCallback","useRef","registerThenCb","useCallback","onfulfilled","current","chain","catchCallback","registerCatchCb","onrejected","finallyCallback","registerFinallyCb","onsettled","cleanupCallback","registerCleanupCb","oncleanup","useMemo","fullfilled","rejected","settled","cleanup","isMounted","useEffect","context","then","value","err"],"mappings":"uDAkDEA,EACAC,GAEA,IC9CMC,ED8CAC,EAAeC,WACfC,EAAiBC,cAAY,SAAAC,GAEjC,OADAJ,EAAaK,QAAUD,EAChBE,GACN,IAEGC,EAAgBN,WAChBO,EAAkBL,cAAY,SAAAM,GAElC,OADAF,EAAcF,QAAUI,EACjBH,GACN,IAEGI,EAAkBT,WAClBU,EAAoBR,cAAY,SAAAS,GAEpC,OADAF,EAAgBL,QAAUO,EACnBN,GACN,IAEGO,EAAkBZ,WAClBa,EAAoBX,cAAY,SAAAY,GAEpC,OADAF,EAAgBR,QAAUU,EACnBT,GACN,IAEGA,EAAaU,UAAQ,WACzB,MAAO,CACLC,WAAYf,EACZgB,SAAUV,EACVW,QAASR,EACTS,QAASN,IAEV,IAEGO,GC/EAtB,EAAeE,UAAAA,GAErBqB,YAAU,WAGR,OAFAvB,EAAaM,SAAAA,EAAU,WAGrBN,EAAaM,SAAAA,IAEd,IAEIF,cAAY,WAAA,OAAMJ,EAAaM,SAAS,KDwF/C,OAlBAiB,YAAU,WACR,IAAMC,EAAe,GAarB,GAXA1B,EAAQ0B,GACLC,KAAK,SAAAC,GACAJ,KAAerB,EAAaK,SAASL,EAAaK,QAAQoB,EAAOF,WAEhE,SAAAG,GACDL,KAAed,EAAcF,SAASE,EAAcF,QAAQqB,EAAKH,aAE9D,WACHF,KAAeX,EAAgBL,SAASK,EAAgBL,QAAQkB,KAGpEV,EAAgBR,QAAS,yBAAaQ,EAAgBR,QAAQkB,KAEjEzB,GAEIQ"}