import { DependencyList } from 'react';
declare type NonVoid<T> = T extends void ? never : T;
declare type NarrowedAsyncEffect<TContext, TResult, TVisited extends string | void, TNarrow extends string> = Omit<AsyncEffect<TContext, TResult, TVisited | TNarrow>, NonVoid<TVisited> | TNarrow>;
interface AsyncEffect<TContext, TResult, TVisited extends string | void = void> {
    /**
     * Registers a callback to execute when the async handler resolves. Analagous
     * to `Promise.then`.
     */
    fullfilled(onfulfilled?: ((value: TResult, context: Partial<TContext>) => void) | null): NarrowedAsyncEffect<TContext, TResult, TVisited, 'fullfilled'>;
    /**
     * Registers a callback to execute when the async handler rejects. Analagous
     * to `Promise.catch`.
     */
    rejected(onrejected?: ((reason: any, context: Partial<TContext>) => void) | null): NarrowedAsyncEffect<TContext, TResult, TVisited, 'rejected'>;
    /**
     * Registers a callback to execute when the async handler completes, whether
     * successfully or not. Analagous to `Promise.finally`.
     */
    settled(onsettled?: ((context: Partial<TContext>) => void) | null): NarrowedAsyncEffect<TContext, TResult, TVisited, 'settled'>;
    /**
     * Registers a callback to execute when the underlying `React.useEffect` is
     * cleaned up.
     */
    cleanup(onfulfilled?: ((context: Partial<TContext>) => void) | null): NarrowedAsyncEffect<TContext, TResult, TVisited, 'cleanup'>;
}
/**
 * Makes asynchronous work inside the React lifecycle easy with automatic guards
 * against updating internal component state if the component is unmounted
 * before the async work is finished.
 */
export declare function useAsyncEffect<TContext extends {
    [key: string]: any;
} = {
    [key: string]: any;
}, TResult = any>(handler: (context: Partial<TContext>) => Promise<TResult>, deps?: DependencyList): AsyncEffect<TContext, TResult>;
export {};
