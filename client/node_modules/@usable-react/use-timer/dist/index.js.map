{"version":3,"file":"index.js","sources":["../../use-compare/dist/index.m.js","../src/index.ts"],"sourcesContent":["import{useEffect as r,useRef as t}from\"react\";function n(n){return c=n,e=t(),r(function(){e.current=c}),e.current!==n;var c,e}export{n as useCompare};\n//# sourceMappingURL=index.m.js.map\n","import { EffectCallback, useCallback, useEffect, useRef, useState } from 'react';\nimport { useCompare } from '@usable-react/use-compare';\n\nexport interface TimerHook {\n  /**\n   * Starts the timer.\n   */\n  start: () => void;\n\n  /**\n   * Pauses the timer. This function has no effect if the timer has not yet\n   * started.\n   */\n  pause: () => void;\n\n  /**\n   * Resumes the timer. This function has no effect if the timer has not yet\n   * started.\n   */\n  resume: () => void;\n\n  /**\n   * Resets the timer.\n   *\n   * @param newLength - Optionally provide a new timer length (in milliseconds).\n   * @param newTick - Optionally provide a new tick length (in milliseconds).\n   */\n  reset: (newLength?: number, newTick?: number) => void;\n\n  /** The amount of time (in milliseconds) remaining in the timer. */\n  remaining: number;\n\n  /** The total expected length of the timer (in milliseconds). */\n  length: number;\n\n  /** A flag indicating whether the timer is currently running. */\n  isRunning: boolean;\n}\n\n/**\n * Returns a timer that works inside the React lifecycle.\n *\n * @param length - The total length of the timer (in milliseconds).\n * @param tick - The interval at which to update the timer (in milliseconds).\n */\nexport function useTimer(options: { length: number; tick?: number; autoStart?: boolean }): TimerHook {\n  const optionsWithDefaults = { ...{ tick: 1000, autoStart: false }, ...options };\n  const { length, tick, autoStart } = optionsWithDefaults;\n\n  const [remaining, setRemaining] = useState(length);\n  const [isRunning, setIsRunning] = useState(autoStart);\n  const lengthRef = useRef(length);\n  const tickRef = useRef(tick);\n  const isStarted = useRef(autoStart);\n\n  // Save the latest `tick` value.\n  useEffect(() => {\n    tickRef.current = tick;\n  }, [tick]);\n\n  // Save the latest `length` value.\n  useEffect(() => {\n    lengthRef.current = length;\n  }, [length]);\n\n  // Build timer functionality callbacks.\n\n  const start = useCallback(() => {\n    if (!isRunning && !isStarted.current) {\n      setIsRunning(true);\n      isStarted.current = true;\n    }\n  }, [isRunning]);\n\n  const pause = useCallback(() => {\n    if (isRunning) setIsRunning(false);\n  }, [isRunning]);\n\n  const resume = useCallback(() => {\n    if (!isRunning && isStarted.current) setIsRunning(true);\n  }, [isRunning]);\n\n  const reset = useCallback(\n    (newLength?: number, newTick?: number) => {\n      if (newTick) tickRef.current = newTick;\n      if (newLength) lengthRef.current = newLength;\n      if (isRunning) setIsRunning(false);\n      setRemaining(newLength || lengthRef.current);\n      isStarted.current = false;\n    },\n    [isRunning],\n  );\n\n  // Update the timer.\n  useEffect(() => {\n    if (isRunning && remaining > 0) {\n      const id = setTimeout(() => {\n        setRemaining(remaining - tickRef.current);\n      }, tickRef.current);\n\n      return () => clearTimeout(id);\n    }\n\n    if (isRunning && remaining === 0) {\n      setIsRunning(false);\n    }\n\n    if (isRunning && remaining < 0) {\n      setRemaining(0);\n      setIsRunning(false);\n    }\n\n    return undefined;\n  }, [remaining, isRunning]);\n\n  return {\n    start,\n    pause,\n    resume,\n    reset,\n    remaining,\n    isRunning,\n    length: lengthRef.current,\n  };\n}\n\n/**\n * Execute an effect if the supplied timer ticks.\n *\n * @param timer - The `TimerHook` object to base effects from.\n * @param effect - Imperative function that can return a cleanup function.\n * @param deps - If present, effect will only activate if the values in the list change.\n */\nexport function useTimerEffect(timer: TimerHook, effect: EffectCallback, deps: readonly any[] = []) {\n  const { isRunning, remaining } = timer;\n  const didTimerChange = useCompare(remaining);\n  const savedCallback = useRef(effect);\n\n  useEffect(() => {\n    savedCallback.current = effect;\n  }, [effect]);\n\n  useEffect(() => {\n    if (isRunning && didTimerChange && remaining > 0) {\n      return savedCallback.current();\n    }\n\n    return undefined;\n  }, [remaining, isRunning, ...deps]);\n}\n\n/**\n * Execute an effect if the supplied timer completes.\n *\n * @param timer - The `TimerHook` object to base effects from.\n * @param effect - Imperative function that can return a cleanup function.\n * @param deps - If present, effect will only activate if the values in the list change.\n */\nexport function useTimerComplete(timer: TimerHook, effect: EffectCallback, deps: readonly any[] = []) {\n  const { remaining } = timer;\n  const didTimerChange = useCompare(remaining);\n  const savedCallback = useRef(effect);\n\n  useEffect(() => {\n    savedCallback.current = effect;\n  }, [effect]);\n\n  useEffect(() => {\n    if (didTimerChange && remaining <= 0) {\n      return savedCallback.current();\n    }\n\n    return undefined;\n  }, [remaining, ...deps]);\n}\n"],"names":["useCompare","value","options","optionsWithDefaults","tick","autoStart","length","useState","remaining","setRemaining","isRunning","setIsRunning","lengthRef","useRef","tickRef","isStarted","useEffect","current","start","useCallback","pause","resume","reset","newLength","newTick","id","setTimeout","clearTimeout","timer","effect","deps","didTimerChange","savedCallback"],"mappings":"+OAMgBA,EAAcC,GAE5B,SAD4BA,gEACTA,EAAAA,kCCqCIC,GACvB,IAAMC,OAA2B,CAAEC,KAAM,IAAMC,WAAW,MAAYH,GAC9DI,EAA4BH,EAA5BG,OAAQF,EAAoBD,EAApBC,KAAMC,EAAcF,EAAdE,YAEYE,WAASD,GAApCE,OAAWC,SACgBF,WAASF,GAApCK,OAAWC,OACZC,EAAYC,SAAOP,GACnBQ,EAAUD,SAAOT,GACjBW,EAAYF,SAAOR,GAGzBW,YAAU,WACRF,EAAQG,QAAUb,GACjB,CAACA,IAGJY,YAAU,WACRJ,EAAUK,QAAUX,GACnB,CAACA,IAIJ,IAAMY,EAAQC,cAAY,WACnBT,GAAcK,EAAUE,UAC3BN,GAAa,GACbI,EAAUE,SAAU,IAErB,CAACP,IAEEU,EAAQD,cAAY,WACpBT,GAAWC,GAAa,IAC3B,CAACD,IAEEW,EAASF,cAAY,YACpBT,GAAaK,EAAUE,SAASN,GAAa,IACjD,CAACD,IAEEY,EAAQH,cACZ,SAACI,EAAoBC,GACfA,IAASV,EAAQG,QAAUO,GAC3BD,IAAWX,EAAUK,QAAUM,GAC/Bb,GAAWC,GAAa,GAC5BF,EAAac,GAAaX,EAAUK,SACpCF,EAAUE,SAAU,GAEtB,CAACP,IAyBH,OArBAM,YAAU,WACR,GAAIN,GAAaF,EAAY,EAAG,CAC9B,IAAMiB,EAAKC,WAAW,WACpBjB,EAAaD,EAAYM,EAAQG,UAChCH,EAAQG,SAEX,yBAAaU,aAAaF,IAGxBf,GAA2B,IAAdF,GACfG,GAAa,GAGXD,GAAaF,EAAY,IAC3BC,EAAa,GACbE,GAAa,KAId,CAACH,EAAWE,IAER,CACLQ,MAAAA,EACAE,MAAAA,EACAC,OAAAA,EACAC,MAAAA,EACAd,UAAAA,EACAE,UAAAA,EACAJ,OAAQM,EAAUK,mCAoCtB,SAAiCW,EAAkBC,EAAwBC,YAAAA,IAAAA,EAAuB,QACxFtB,EAAcoB,EAAdpB,UACFuB,EAAiB/B,EAAWQ,GAC5BwB,EAAgBnB,SAAOgB,GAE7Bb,YAAU,WACRgB,EAAcf,QAAUY,GACvB,CAACA,IAEJb,YAAU,WACR,GAAIe,GAAkBvB,GAAa,EACjC,OAAOwB,EAAcf,YAIrBT,UAAcsB,4BAxCpB,SAA+BF,EAAkBC,EAAwBC,YAAAA,IAAAA,EAAuB,QACtFpB,EAAyBkB,EAAzBlB,UAAWF,EAAcoB,EAAdpB,UACbuB,EAAiB/B,EAAWQ,GAC5BwB,EAAgBnB,SAAOgB,GAE7Bb,YAAU,WACRgB,EAAcf,QAAUY,GACvB,CAACA,IAEJb,YAAU,WACR,GAAIN,GAAaqB,GAAkBvB,EAAY,EAC7C,OAAOwB,EAAcf,YAIrBT,EAAWE,UAAcoB"}