{"version":3,"file":"index.m.js","sources":["../src/index.ts","../../use-compare/dist/index.m.js"],"sourcesContent":["import { EffectCallback, useCallback, useEffect, useRef, useState } from 'react';\nimport { useCompare } from '@usable-react/use-compare';\n\n/**\n * Exactly like `useEffect`, except that it returns a memoized function to\n * trigger the effect in question. The effect only executes when the trigger\n * updates regardless of the given `deps`.\n *\n * A few use-cases for this hook include:\n *\n * 1. Deferring an effect to the next render tick.\n * 2. Sequencing asynchronous effects.\n * 3. Executing an effect after marshalling arbitrary state/data required for\n *    the effect to proceed.\n */\nexport function useEffectTrigger(effect: EffectCallback, deps: readonly any[] = []) {\n  const [trigger, setTrigger] = useState(0);\n  const didTriggerUpdate = useCompare(trigger);\n  const savedCallback = useRef(effect);\n\n  useEffect(() => {\n    savedCallback.current = effect;\n  }, [effect]);\n\n  useEffect(() => {\n    if (didTriggerUpdate) {\n      return savedCallback.current();\n    }\n\n    return undefined;\n  }, [trigger, ...deps]);\n\n  return useCallback(() => setTrigger(trigger + 1), [trigger]);\n}\n","import{useEffect as r,useRef as t}from\"react\";function n(n){return c=n,e=t(),r(function(){e.current=c}),e.current!==n;var c,e}export{n as useCompare};\n//# sourceMappingURL=index.m.js.map\n"],"names":["useEffectTrigger","effect","deps","value","useState","trigger","setTrigger","didTriggerUpdate","savedCallback","useRef","useEffect","current","useCallback"],"mappings":"sFAegBA,EAAiBC,EAAwBC,YAAAA,IAAAA,EAAuB,QCTlDC,QDUEC,EAAS,GAAhCC,OAASC,OACVC,KCXsBJ,EDWQE,+CCTjBF,GDUbK,EAAgBC,EAAOR,GAc7B,OAZAS,EAAU,WACRF,EAAcG,QAAUV,GACvB,CAACA,IAEJS,EAAU,WACR,GAAIH,EACF,OAAOC,EAAcG,YAIrBN,UAAYH,IAETU,EAAY,kBAAMN,EAAWD,EAAU,IAAI,CAACA"}