{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.propKey = propKey;\nexports.intersection = intersection;\nexports.createRuleSet = createRuleSet;\nexports.createClassName = createClassName;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n/**\n * Extracts the single breakpoint prop from the props object.\n */\n\n\nfunction propKey(breakpointProps) {\n  return Object.keys(breakpointProps)[0];\n}\n/**\n * Returns the intersection of two arrays.\n */\n\n\nfunction intersection(a1, a2) {\n  return a2 ? a1.filter(function (element) {\n    return a2.indexOf(element) >= 0;\n  }) : _toConsumableArray(a1);\n}\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\n\n\nfunction createRuleSet(className, query) {\n  return \"@media \".concat(query, \"{.\").concat(className, \"{display:none!important;}}\");\n}\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\n\n\nfunction createClassName() {\n  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n    components[_key] = arguments[_key];\n  }\n\n  return [\"fresnel\"].concat(_toConsumableArray(components.reduce(function (acc, breakpoint) {\n    return Array.isArray(breakpoint) ? _toConsumableArray(acc).concat(_toConsumableArray(breakpoint)) : _toConsumableArray(acc).concat([breakpoint]);\n  }, []))).join(\"-\");\n}","map":{"version":3,"sources":["../src/Utils.ts"],"names":["Object","a2","components","Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;;;;;AAGO,SAAA,OAAA,CAAA,eAAA,EAAwD;AAC7D,SAAOA,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAP,CAAOA,CAAP;AACD;AAED;;;;;AAGO,SAAA,YAAA,CAAA,EAAA,EAAA,EAAA,EAGE;AACP,SAAOC,EAAE,GAAG,EAAE,CAAF,MAAA,CAAU,UAAA,OAAA,EAAO;AAAA,WAAIA,EAAE,CAAFA,OAAAA,CAAAA,OAAAA,KAAJ,CAAA;AAApB,GAAG,CAAH,GAAA,kBAAA,CAAT,EAAS,CAAT;AACD;AAED;;;;;;AAIO,SAAA,aAAA,CAAA,SAAA,EAAA,KAAA,EAAyD;AAC9D,SAAA,UAAA,MAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,CAAA,SAAA,EAAA,4BAAA,CAAA;AACD;AAED;;;;;AAGO,SAAA,eAAA,GAEL;AAAA,OAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EADGC,UACH,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AADGA,IAAAA,UACH,CAAA,IAAA,CADGA,GACH,SAAA,CAAA,IAAA,CADGA;AACH;;AACA,SAAO,CAAA,SAAA,EAAA,MAAA,CAAA,kBAAA,CAEF,UAAU,CAAV,MAAA,CACD,UAAA,GAAA,EAAA,UAAA,EAAA;AAAA,WACEC,KAAK,CAALA,OAAAA,CAAAA,UAAAA,IAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,kBAAAA,CAAAA,UAAAA,CAAAA,CAAAA,GAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CADF,UACEA,CAAAA,CADF;AADC,GAAA,EAFE,EAEF,CAFE,CAAA,EAAA,IAAA,CAAP,GAAO,CAAP;AAUD","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n"]},"metadata":{},"sourceType":"script"}