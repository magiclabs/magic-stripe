{"ast":null,"code":"function e(e, t) {\n  return new Promise(function (n, o) {\n    if (null == e) return o(Promise.reject(new Error(\"[watch-resize] The given element must be defined.\")));\n    if (!function (e) {\n      try {\n        return e instanceof HTMLElement;\n      } catch (t) {\n        return \"object\" == typeof e && 1 === e.nodeType && \"object\" == typeof e.style && \"object\" == typeof e.ownerDocument;\n      }\n    }(e)) return o(Promise.reject(new Error(\"[watch-resize] The given element is not a valid DOM node.\")));\n    if (!e.parentNode) return o(Promise.reject(new Error(\"[watch-resize] The given element is not yet attached to the DOM.\")));\n    \"static\" === getComputedStyle(e).position && (e.style.position = \"relative\");\n    var i = document.createElement(\"object\");\n    i.type = \"text/html\", i.data = \"about:blank\", i.style.display = \"block\", i.style.position = \"absolute\", i.style.top = \"0\", i.style.left = \"0\", i.style.height = \"100%\", i.style.width = \"100%\", i.style.overflow = \"hidden\", i.style.pointerEvents = \"none\", i.style.zIndex = \"-1\";\n    var r = e.getBoundingClientRect();\n    i.addEventListener(\"load\", function () {\n      if (i.contentDocument && i.contentDocument.defaultView) {\n        var l = i.contentDocument.defaultView,\n            s = function (n) {\n          t({\n            element: e,\n            event: n,\n            prevBoundingClientRect: r,\n            destroy: c\n          }), r = e.getBoundingClientRect();\n        },\n            c = function () {\n          l.removeEventListener(\"resize\", s), i.remove();\n        };\n\n        l.addEventListener(\"resize\", s), n(c);\n      } else o(new Error(\"[watch-resize] Failed to build a nested browsing context.\"));\n    }), e.appendChild(i);\n  });\n}\n\nexport { e as watchResize };","map":{"version":3,"sources":["../src/lib.ts"],"names":["obj","HTMLElement","e","nodeType","style","ownerDocument","watchResize","element","handler","Promise","resolve","reject","Error","isElement","parentNode","getComputedStyle","position","document","createElement","type","data","display","top","left","height","width","overflow","pointerEvents","zIndex","prevBoundingClientRect","getBoundingClientRect","addEventListener","contentDocument","defaultView","viewContext","listener","event","destroy","removeEventListener","remove","appendChild"],"mappings":"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","sourcesContent":["/**\n * Payload received by a `ResizeHandler`.\n */\nexport interface ResizePayload<T extends HTMLElement> {\n  element: T;\n  event: UIEvent;\n  prevBoundingClientRect: ClientRect | DOMRect;\n  destroy: DestroyWatcher;\n}\n\n/**\n * A callback function invoked when the\n * watched element emits a \"resize\" event.\n */\nexport type ResizeHandler<T extends HTMLElement> = (payload: ResizePayload<T>) => void | Promise<void>;\n\n/**\n * A synchronous function to unobserve\n * the element given to `watchResize`.\n */\nexport type DestroyWatcher = () => void;\n\n/**\n * Checks if the given object is a valid `HTMLElement`.\n */\nfunction isElement(obj: any) {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return obj instanceof HTMLElement;\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return (\n      typeof obj === 'object' &&\n      obj.nodeType === 1 &&\n      typeof obj.style === 'object' &&\n      typeof obj.ownerDocument === 'object'\n    );\n  }\n}\n\n/**\n * Returns a Promise that resolves to a RxJS Observable. The Observable fires\n * when the given DOM element's width or height changes.\n *\n * @param element - HTMLElement to observe.\n * @param handler - A callback function invoked whenever the given `element`\n * resizes.\n */\nexport function watchResize<T extends HTMLElement>(element: T, handler: ResizeHandler<T>): Promise<DestroyWatcher> {\n  return new Promise<DestroyWatcher>((resolve, reject) => {\n    // Assert that `element` is defined and is a valid DOM node.\n    if (typeof element === 'undefined' || element === null) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element must be defined.')));\n    }\n\n    if (!isElement(element)) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element is not a valid DOM node.')));\n    }\n\n    if (!element.parentNode) {\n      return reject(Promise.reject(new Error('[watch-resize] The given element is not yet attached to the DOM.')));\n    }\n\n    // Ensure we are relatively positioned so that the nested browsing context\n    // is correctly sized and positioned.\n    if (getComputedStyle(element).position === 'static') {\n      element.style.position = 'relative';\n    }\n\n    // Create a nested browsing context using an <object> element.\n    const obj = document.createElement('object');\n\n    // Set type and data\n    obj.type = 'text/html';\n    obj.data = 'about:blank';\n\n    // Set CSSOM properties\n    obj.style.display = 'block';\n    obj.style.position = 'absolute';\n    obj.style.top = '0';\n    obj.style.left = '0';\n    obj.style.height = '100%';\n    obj.style.width = '100%';\n    obj.style.overflow = 'hidden';\n    obj.style.pointerEvents = 'none';\n    obj.style.zIndex = '-1';\n\n    // Save a reference to the element's current client rect.\n    let prevBoundingClientRect: ClientRect | DOMRect = element.getBoundingClientRect();\n\n    // When the <object> loads, apply the \"resize\" event listener and resolve.\n    obj.addEventListener('load', () => {\n      if (obj.contentDocument && obj.contentDocument.defaultView) {\n        const viewContext = obj.contentDocument.defaultView;\n\n        const listener = (event: UIEvent) => {\n          handler({ element, event, prevBoundingClientRect, destroy });\n          prevBoundingClientRect = element.getBoundingClientRect();\n        };\n\n        const destroy = () => {\n          viewContext.removeEventListener('resize', listener);\n          obj.remove();\n        };\n\n        viewContext.addEventListener('resize', listener);\n\n        resolve(destroy);\n      } else {\n        reject(new Error('[watch-resize] Failed to build a nested browsing context.'));\n      }\n    });\n\n    // Append the <object> to the target element.\n    element.appendChild(obj);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}