{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Breakpoints = exports.BreakpointConstraint = void 0;\n\nvar _Utils = require(\"./Utils\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction breakpointKey(breakpoint) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint;\n}\n\nvar BreakpointConstraint;\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\n\nexports.BreakpointConstraint = BreakpointConstraint;\n\n(function (BreakpointConstraint) {\n  BreakpointConstraint[\"at\"] = \"at\";\n  BreakpointConstraint[\"lessThan\"] = \"lessThan\";\n  BreakpointConstraint[\"greaterThan\"] = \"greaterThan\";\n  BreakpointConstraint[\"greaterThanOrEqual\"] = \"greaterThanOrEqual\";\n  BreakpointConstraint[\"between\"] = \"between\";\n})(BreakpointConstraint || (exports.BreakpointConstraint = BreakpointConstraint = {}));\n\nvar Breakpoints = /*#__PURE__*/function () {\n  _createClass(Breakpoints, null, [{\n    key: \"validKeys\",\n    value: function validKeys() {\n      return [BreakpointConstraint.at, BreakpointConstraint.lessThan, BreakpointConstraint.greaterThan, BreakpointConstraint.greaterThanOrEqual, BreakpointConstraint.between];\n    }\n  }]);\n\n  function Breakpoints(_breakpoints) {\n    var _this = this,\n        _this$_mediaQueries;\n\n    _classCallCheck(this, Breakpoints);\n\n    _defineProperty(this, \"_sortedBreakpoints\", void 0);\n\n    _defineProperty(this, \"_breakpoints\", void 0);\n\n    _defineProperty(this, \"_mediaQueries\", void 0);\n\n    _defineProperty(this, \"findBreakpointsForWidths\", function (fromWidth, throughWidth) {\n      var fromBreakpoint = _this.findBreakpointAtWidth(fromWidth);\n\n      if (!fromBreakpoint) {\n        return undefined;\n      }\n\n      var throughBreakpoint = _this.findBreakpointAtWidth(throughWidth);\n\n      if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n        return [fromBreakpoint];\n      } else {\n        return _this._sortedBreakpoints.slice(_this._sortedBreakpoints.indexOf(fromBreakpoint), _this._sortedBreakpoints.indexOf(throughBreakpoint) + 1);\n      }\n    });\n\n    _defineProperty(this, \"findBreakpointAtWidth\", function (width) {\n      return _this._sortedBreakpoints.find(function (breakpoint, i) {\n        var nextBreakpoint = _this._sortedBreakpoints[i + 1];\n\n        if (nextBreakpoint) {\n          return width >= _this._breakpoints[breakpoint] && width < _this._breakpoints[nextBreakpoint];\n        } else {\n          return width >= _this._breakpoints[breakpoint];\n        }\n      });\n    });\n\n    _defineProperty(this, \"valuesWithBreakpointProps\", function (values) {\n      var max = values.length;\n      var valueBreakpoints = [];\n      var lastTuple;\n\n      _this._sortedBreakpoints.forEach(function (breakpoint, i) {\n        var value = values[i];\n\n        if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n          lastTuple = [value, [breakpoint]];\n          valueBreakpoints.push(lastTuple);\n        } else {\n          lastTuple[1].push(breakpoint);\n        }\n      });\n\n      return valueBreakpoints.map(function (_ref, i) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            value = _ref2[0],\n            breakpoints = _ref2[1];\n\n        var props = {};\n\n        if (i === valueBreakpoints.length - 1) {\n          props.greaterThanOrEqual = breakpoints[0];\n        } else if (breakpoints.length === 1) {\n          props.at = breakpoints[0];\n        } else {\n          // TODO: This is less than ideal, would be good to have a `through`\n          //       prop, which unlike `between` is inclusive.\n          props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]];\n        }\n\n        return [value, props];\n      });\n    });\n\n    this._breakpoints = _breakpoints;\n    this._sortedBreakpoints = Object.keys(_breakpoints).map(function (breakpoint) {\n      return [breakpoint, _breakpoints[breakpoint]];\n    }).sort(function (a, b) {\n      return a[1] < b[1] ? -1 : 1;\n    }).map(function (breakpointAndValue) {\n      return breakpointAndValue[0];\n    }); // List of all possible and valid `between` combinations\n\n    var betweenCombinations = this._sortedBreakpoints.slice(0, -1).reduce(function (acc, b1, i) {\n      return _toConsumableArray(acc).concat(_toConsumableArray(_this._sortedBreakpoints.slice(i + 1).map(function (b2) {\n        return [b1, b2];\n      })));\n    }, []);\n\n    this._mediaQueries = (_this$_mediaQueries = {}, _defineProperty(_this$_mediaQueries, BreakpointConstraint.at, this._createBreakpointQueries(BreakpointConstraint.at, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.lessThan, this._createBreakpointQueries(BreakpointConstraint.lessThan, this._sortedBreakpoints.slice(1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThan, this._createBreakpointQueries(BreakpointConstraint.greaterThan, this._sortedBreakpoints.slice(0, -1))), _defineProperty(_this$_mediaQueries, BreakpointConstraint.greaterThanOrEqual, this._createBreakpointQueries(BreakpointConstraint.greaterThanOrEqual, this._sortedBreakpoints)), _defineProperty(_this$_mediaQueries, BreakpointConstraint.between, this._createBreakpointQueries(BreakpointConstraint.between, betweenCombinations)), _this$_mediaQueries);\n  }\n\n  _createClass(Breakpoints, [{\n    key: \"toVisibleAtBreakpointSet\",\n    value: function toVisibleAtBreakpointSet(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.lessThan;\n        });\n        return this.sortedBreakpoints.slice(0, breakpointIndex);\n      } else if (breakpointProps.greaterThan) {\n        var _breakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThan;\n        });\n\n        return this.sortedBreakpoints.slice(_breakpointIndex + 1);\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _breakpointIndex2 = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === breakpointProps.greaterThanOrEqual;\n        });\n\n        return this.sortedBreakpoints.slice(_breakpointIndex2);\n      } else if (breakpointProps.between) {\n        var _between = breakpointProps.between;\n        var fromBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === _between[0];\n        });\n        var toBreakpointIndex = this.sortedBreakpoints.findIndex(function (bp) {\n          return bp === _between[1];\n        });\n        return this.sortedBreakpoints.slice(fromBreakpointIndex, toBreakpointIndex);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"toRuleSets\",\n    value: function toRuleSets() {\n      var _this2 = this;\n\n      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Breakpoints.validKeys();\n      var selectedMediaQueries = keys.reduce(function (mediaQueries, query) {\n        mediaQueries[query] = _this2._mediaQueries[query];\n        return mediaQueries;\n      }, {});\n      return Object.entries(selectedMediaQueries).reduce(function (acc, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            type = _ref4[0],\n            queries = _ref4[1];\n\n        queries.forEach(function (query, breakpoint) {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push((0, _Utils.createRuleSet)((0, _Utils.createClassName)(type, breakpoint), \"not all and \".concat(query)));\n        });\n        return acc;\n      }, []);\n    }\n  }, {\n    key: \"shouldRenderMediaQuery\",\n    value: function shouldRenderMediaQuery(breakpointProps, onlyRenderAt) {\n      var _this3 = this;\n\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        var lowestAllowedWidth = Math.min.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return lowestAllowedWidth < width;\n      } else if (breakpointProps.greaterThan) {\n        var _width = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n\n        var highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n        return highestAllowedWidth >= _width;\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width2 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n\n        var _highestAllowedWidth = Math.max.apply(Math, _toConsumableArray(onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        })));\n\n        return _highestAllowedWidth >= _width2;\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `oustide`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        var allowedWidths = onlyRenderAt.map(function (breakpoint) {\n          return _this3._breakpoints[breakpoint];\n        });\n        return !(Math.max.apply(Math, _toConsumableArray(allowedWidths)) < fromWidth || Math.min.apply(Math, _toConsumableArray(allowedWidths)) >= toWidth);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_normalizeProps\",\n    value: function _normalizeProps(breakpointProps) {\n      if (breakpointProps.at) {\n        var fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at);\n\n        var to = this._sortedBreakpoints[fromIndex + 1];\n        return to ? {\n          between: [breakpointProps.at, to]\n        } : {\n          greaterThanOrEqual: breakpointProps.at\n        };\n      }\n\n      return breakpointProps;\n    }\n  }, {\n    key: \"_createBreakpointQuery\",\n    value: function _createBreakpointQuery(breakpointProps) {\n      breakpointProps = this._normalizeProps(breakpointProps);\n\n      if (breakpointProps.lessThan) {\n        var width = this._breakpoints[breakpointProps.lessThan];\n        return \"(max-width:\".concat(width - 1, \"px)\");\n      } else if (breakpointProps.greaterThan) {\n        var _width3 = this._breakpoints[this._findNextBreakpoint(breakpointProps.greaterThan)];\n\n        return \"(min-width:\".concat(_width3, \"px)\");\n      } else if (breakpointProps.greaterThanOrEqual) {\n        var _width4 = this._breakpoints[breakpointProps.greaterThanOrEqual];\n        return \"(min-width:\".concat(_width4, \"px)\");\n      } else if (breakpointProps.between) {\n        // TODO: This is the only useful breakpoint to negate, but we’ll\n        //       we’ll see when/if we need it. We could then also decide\n        //       to add `outside`.\n        var fromWidth = this._breakpoints[breakpointProps.between[0]];\n        var toWidth = this._breakpoints[breakpointProps.between[1]];\n        return \"(min-width:\".concat(fromWidth, \"px) and (max-width:\").concat(toWidth - 1, \"px)\");\n      }\n\n      throw new Error(\"Unexpected breakpoint props: \".concat(JSON.stringify(breakpointProps)));\n    }\n  }, {\n    key: \"_createBreakpointQueries\",\n    value: function _createBreakpointQueries(key, forBreakpoints) {\n      var _this4 = this;\n\n      return forBreakpoints.reduce(function (map, breakpoint) {\n        map.set(breakpointKey(breakpoint), _this4._createBreakpointQuery(_defineProperty({}, key, breakpoint)));\n        return map;\n      }, new Map());\n    }\n  }, {\n    key: \"_findNextBreakpoint\",\n    value: function _findNextBreakpoint(breakpoint) {\n      var nextBreakpoint = this._sortedBreakpoints[this._sortedBreakpoints.indexOf(breakpoint) + 1];\n\n      if (!nextBreakpoint) {\n        throw new Error(\"There is no breakpoint larger than \".concat(breakpoint));\n      }\n\n      return nextBreakpoint;\n    }\n  }, {\n    key: \"sortedBreakpoints\",\n    get: function get() {\n      return this._sortedBreakpoints;\n    }\n  }, {\n    key: \"dynamicResponsiveMediaQueries\",\n    get: function get() {\n      return Array.from(this._mediaQueries[BreakpointConstraint.at].entries()).reduce(function (acc, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            k = _ref6[0],\n            v = _ref6[1];\n\n        return _objectSpread({}, acc, _defineProperty({}, k, v));\n      }, {});\n    }\n  }, {\n    key: \"largestBreakpoint\",\n    get: function get() {\n      return this._sortedBreakpoints[this._sortedBreakpoints.length - 1];\n    }\n  }]);\n\n  return Breakpoints;\n}();\n\nexports.Breakpoints = Breakpoints;","map":{"version":3,"sources":["../src/Breakpoints.ts"],"names":["Array","breakpoint","BreakpointConstraint","Breakpoints","breakpoints","a","b","breakpointAndValue","betweenCombinations","i","k","v","fromBreakpoint","throughBreakpoint","nextBreakpoint","width","breakpointProps","breakpointIndex","bp","between","fromBreakpointIndex","toBreakpointIndex","keys","selectedMediaQueries","mediaQueries","type","queries","acc","onlyRenderAt","lowestAllowedWidth","Math","highestAllowedWidth","fromWidth","toWidth","allowedWidths","max","values","valueBreakpoints","value","lastTuple","props","fromIndex","to","greaterThanOrEqual","at","JSON","key","forBreakpoints","map","breakpointKey"],"mappings":"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","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { createRuleSet, createClassName } from \"./Utils\"\n\n/**\n * A union of possible breakpoint props.\n */\nexport type BreakpointConstraintKey = keyof MediaBreakpointProps\n\ntype ValueBreakpointPropsTuple<SizeValue, BreakpointKey> = [\n  SizeValue,\n  MediaBreakpointProps<BreakpointKey>\n]\n\ntype Tuple = [string, string]\n\nfunction breakpointKey(breakpoint: string | Tuple) {\n  return Array.isArray(breakpoint) ? breakpoint.join(\"-\") : breakpoint\n}\n\nexport enum BreakpointConstraint {\n  at = \"at\",\n  lessThan = \"lessThan\",\n  greaterThan = \"greaterThan\",\n  greaterThanOrEqual = \"greaterThanOrEqual\",\n  between = \"between\",\n}\n\n/**\n * Encapsulates all breakpoint data needed by the Media component. The data is\n * generated on initialization so no further runtime work is necessary.\n */\nexport class Breakpoints<BreakpointKey extends string> {\n  static validKeys() {\n    return [\n      BreakpointConstraint.at,\n      BreakpointConstraint.lessThan,\n      BreakpointConstraint.greaterThan,\n      BreakpointConstraint.greaterThanOrEqual,\n      BreakpointConstraint.between,\n    ]\n  }\n\n  private _sortedBreakpoints: ReadonlyArray<string>\n  private _breakpoints: Record<string, number>\n  private _mediaQueries: Record<BreakpointConstraint, Map<string, string>>\n\n  constructor(breakpoints: { [key: string]: number }) {\n    this._breakpoints = breakpoints\n\n    this._sortedBreakpoints = Object.keys(breakpoints)\n      .map(breakpoint => [breakpoint, breakpoints[breakpoint]])\n      .sort((a, b) => (a[1] < b[1] ? -1 : 1))\n      .map(breakpointAndValue => breakpointAndValue[0] as string)\n\n    // List of all possible and valid `between` combinations\n    const betweenCombinations = this._sortedBreakpoints\n      .slice(0, -1)\n      .reduce(\n        (acc: Tuple[], b1, i) => [\n          ...acc,\n          ...this._sortedBreakpoints.slice(i + 1).map(b2 => [b1, b2] as Tuple),\n        ],\n        []\n      )\n\n    this._mediaQueries = {\n      [BreakpointConstraint.at]: this._createBreakpointQueries(\n        BreakpointConstraint.at,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.lessThan]: this._createBreakpointQueries(\n        BreakpointConstraint.lessThan,\n        this._sortedBreakpoints.slice(1)\n      ),\n      [BreakpointConstraint.greaterThan]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThan,\n        this._sortedBreakpoints.slice(0, -1)\n      ),\n      [BreakpointConstraint.greaterThanOrEqual]: this._createBreakpointQueries(\n        BreakpointConstraint.greaterThanOrEqual,\n        this._sortedBreakpoints\n      ),\n      [BreakpointConstraint.between]: this._createBreakpointQueries(\n        BreakpointConstraint.between,\n        betweenCombinations\n      ),\n    }\n  }\n\n  public get sortedBreakpoints() {\n    return this._sortedBreakpoints as BreakpointKey[]\n  }\n\n  public get dynamicResponsiveMediaQueries() {\n    return Array.from(\n      this._mediaQueries[BreakpointConstraint.at].entries()\n    ).reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {})\n  }\n\n  public get largestBreakpoint() {\n    return this._sortedBreakpoints[this._sortedBreakpoints.length - 1]\n  }\n\n  public findBreakpointsForWidths = (\n    fromWidth: number,\n    throughWidth: number\n  ) => {\n    const fromBreakpoint = this.findBreakpointAtWidth(fromWidth)\n    if (!fromBreakpoint) {\n      return undefined\n    }\n    const throughBreakpoint = this.findBreakpointAtWidth(throughWidth)\n    if (!throughBreakpoint || fromBreakpoint === throughBreakpoint) {\n      return [fromBreakpoint] as BreakpointKey[]\n    } else {\n      return this._sortedBreakpoints.slice(\n        this._sortedBreakpoints.indexOf(fromBreakpoint),\n        this._sortedBreakpoints.indexOf(throughBreakpoint) + 1\n      ) as BreakpointKey[]\n    }\n  }\n\n  public findBreakpointAtWidth = (width: number) => {\n    return this._sortedBreakpoints.find((breakpoint, i) => {\n      const nextBreakpoint = this._sortedBreakpoints[i + 1]\n      if (nextBreakpoint) {\n        return (\n          width >= this._breakpoints[breakpoint] &&\n          width < this._breakpoints[nextBreakpoint]\n        )\n      } else {\n        return width >= this._breakpoints[breakpoint]\n      }\n    }) as BreakpointKey | undefined\n  }\n\n  public toVisibleAtBreakpointSet(breakpointProps: MediaBreakpointProps) {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.lessThan\n      )\n      return this.sortedBreakpoints.slice(0, breakpointIndex)\n    } else if (breakpointProps.greaterThan) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThan\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex + 1)\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const breakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === breakpointProps.greaterThanOrEqual\n      )\n      return this.sortedBreakpoints.slice(breakpointIndex)\n    } else if (breakpointProps.between) {\n      const between = breakpointProps.between\n      const fromBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[0]\n      )\n      const toBreakpointIndex = this.sortedBreakpoints.findIndex(\n        bp => bp === between[1]\n      )\n      return this.sortedBreakpoints.slice(\n        fromBreakpointIndex,\n        toBreakpointIndex\n      )\n    }\n    return []\n  }\n\n  public toRuleSets(keys = Breakpoints.validKeys()) {\n    const selectedMediaQueries = keys.reduce(\n      (mediaQueries, query) => {\n        mediaQueries[query] = this._mediaQueries[query]\n        return mediaQueries\n      },\n      {} as Record<BreakpointConstraint, Map<string, string>>\n    )\n\n    return Object.entries(selectedMediaQueries).reduce(\n      (acc: string[], [type, queries]) => {\n        queries.forEach((query, breakpoint) => {\n          // We need to invert the query, such that it matches when we want the\n          // element to be hidden.\n          acc.push(\n            createRuleSet(\n              createClassName(type, breakpoint),\n              `not all and ${query}`\n            )\n          )\n        })\n        return acc\n      },\n      []\n    )\n  }\n\n  public shouldRenderMediaQuery(\n    breakpointProps: MediaBreakpointProps,\n    onlyRenderAt: string[]\n  ): boolean {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      const lowestAllowedWidth = Math.min(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return lowestAllowedWidth < width\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      const highestAllowedWidth = Math.max(\n        ...onlyRenderAt.map(breakpoint => this._breakpoints[breakpoint])\n      )\n      return highestAllowedWidth >= width\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `oustide`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      const allowedWidths = onlyRenderAt.map(\n        breakpoint => this._breakpoints[breakpoint]\n      )\n      return !(\n        Math.max(...allowedWidths) < fromWidth ||\n        Math.min(...allowedWidths) >= toWidth\n      )\n    }\n    return false\n  }\n\n  public valuesWithBreakpointProps = <SizeValue>(\n    values: SizeValue[]\n  ): Array<ValueBreakpointPropsTuple<SizeValue, BreakpointKey>> => {\n    type ValueBreakpoints = [SizeValue, string[]]\n    const max = values.length\n    const valueBreakpoints: ValueBreakpoints[] = []\n    let lastTuple: ValueBreakpoints\n    this._sortedBreakpoints.forEach((breakpoint, i) => {\n      const value = values[i]\n      if (i < max && (!lastTuple || lastTuple[0] !== value)) {\n        lastTuple = [value, [breakpoint]]\n        valueBreakpoints.push(lastTuple)\n      } else {\n        lastTuple[1].push(breakpoint)\n      }\n    })\n\n    return valueBreakpoints.map(([value, breakpoints], i) => {\n      const props: MediaBreakpointProps<any> = {}\n      if (i === valueBreakpoints.length - 1) {\n        props.greaterThanOrEqual = breakpoints[0]\n      } else if (breakpoints.length === 1) {\n        props.at = breakpoints[0]\n      } else {\n        // TODO: This is less than ideal, would be good to have a `through`\n        //       prop, which unlike `between` is inclusive.\n        props.between = [breakpoints[0], valueBreakpoints[i + 1][1][0]]\n      }\n      return [value, props] as ValueBreakpointPropsTuple<\n        SizeValue,\n        BreakpointKey\n      >\n    })\n  }\n\n  private _normalizeProps(\n    breakpointProps: MediaBreakpointProps\n  ): MediaBreakpointProps {\n    if (breakpointProps.at) {\n      const fromIndex = this._sortedBreakpoints.indexOf(breakpointProps.at)\n      const to = this._sortedBreakpoints[fromIndex + 1]\n      return to\n        ? { between: [breakpointProps.at, to] }\n        : { greaterThanOrEqual: breakpointProps.at }\n    }\n    return breakpointProps\n  }\n\n  private _createBreakpointQuery(\n    breakpointProps: MediaBreakpointProps\n  ): string {\n    breakpointProps = this._normalizeProps(breakpointProps)\n    if (breakpointProps.lessThan) {\n      const width = this._breakpoints[breakpointProps.lessThan]\n      return `(max-width:${width - 1}px)`\n    } else if (breakpointProps.greaterThan) {\n      const width = this._breakpoints[\n        this._findNextBreakpoint(breakpointProps.greaterThan)\n      ]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.greaterThanOrEqual) {\n      const width = this._breakpoints[breakpointProps.greaterThanOrEqual]\n      return `(min-width:${width}px)`\n    } else if (breakpointProps.between) {\n      // TODO: This is the only useful breakpoint to negate, but we’ll\n      //       we’ll see when/if we need it. We could then also decide\n      //       to add `outside`.\n      const fromWidth = this._breakpoints[breakpointProps.between[0]]\n      const toWidth = this._breakpoints[breakpointProps.between[1]]\n      return `(min-width:${fromWidth}px) and (max-width:${toWidth - 1}px)`\n    }\n    throw new Error(\n      `Unexpected breakpoint props: ${JSON.stringify(breakpointProps)}`\n    )\n  }\n\n  private _createBreakpointQueries(\n    key: BreakpointConstraintKey,\n    forBreakpoints: ReadonlyArray<string | [string, string]>\n  ) {\n    return forBreakpoints.reduce<Map<string, string>>((map, breakpoint) => {\n      map.set(\n        breakpointKey(breakpoint),\n        this._createBreakpointQuery({\n          [key]: breakpoint,\n        })\n      )\n      return map\n    }, new Map())\n  }\n\n  private _findNextBreakpoint(breakpoint: string) {\n    const nextBreakpoint = this._sortedBreakpoints[\n      this._sortedBreakpoints.indexOf(breakpoint) + 1\n    ]\n    if (!nextBreakpoint) {\n      throw new Error(`There is no breakpoint larger than ${breakpoint}`)\n    }\n    return nextBreakpoint\n  }\n}\n"]},"metadata":{},"sourceType":"script"}