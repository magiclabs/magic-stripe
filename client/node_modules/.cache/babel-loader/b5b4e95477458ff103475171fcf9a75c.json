{"ast":null,"code":"import { createTypedEmitter } from './events';\nvar promiEventBrand = Symbol('isPromiEvent');\n/**\n * Returns `true` if the given `value` is a `PromiEvent`.\n */\n\nexport function isPromiEvent(value) {\n  return !!value[promiEventBrand];\n}\n/**\n * Create a native JavaScript `Promise` overloaded with strongly-typed methods\n * from `EventEmitter`.\n */\n\nexport function createPromiEvent(executor) {\n  var promise = createPromise(executor);\n\n  var _a = createTypedEmitter(),\n      createBoundEmitterMethod = _a.createBoundEmitterMethod,\n      createChainingEmitterMethod = _a.createChainingEmitterMethod; // We save the original `Promise` methods to the following symbols so we can\n  // access them internally.\n\n\n  var thenSymbol = Symbol('Promise.then');\n  var catchSymbol = Symbol('Promise.catch');\n  var finallySymbol = Symbol('Promise.finally');\n  /**\n   * Ensures the next object in the `PromiEvent` chain is overloaded with\n   * `EventEmitter` methods.\n   */\n\n  var createChainingPromiseMethod = function (method, source) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var nextPromise = source[method].apply(source, args);\n      return promiEvent(nextPromise);\n    };\n  };\n  /**\n   * Builds a `PromiEvent` by assigning `EventEmitter` methods to a native\n   * `Promise` object.\n   */\n\n\n  var promiEvent = function (source) {\n    var _a;\n\n    return Object.assign(source, (_a = {}, _a[promiEventBrand] = true, _a[thenSymbol] = source[thenSymbol] || source.then, _a[catchSymbol] = source[catchSymbol] || source.catch, _a[finallySymbol] = source[finallySymbol] || source.finally, _a.then = createChainingPromiseMethod(thenSymbol, source), _a.catch = createChainingPromiseMethod(catchSymbol, source), _a.finally = createChainingPromiseMethod(finallySymbol, source), _a.on = createChainingEmitterMethod('on', source), _a.once = createChainingEmitterMethod('once', source), _a.addListener = createChainingEmitterMethod('addListener', source), _a.off = createChainingEmitterMethod('off', source), _a.removeListener = createChainingEmitterMethod('removeListener', source), _a.removeAllListeners = createChainingEmitterMethod('removeAllListeners', source), _a.emit = createBoundEmitterMethod('emit'), _a.eventNames = createBoundEmitterMethod('eventNames'), _a.listeners = createBoundEmitterMethod('listeners'), _a.listenerCount = createBoundEmitterMethod('listenerCount'), _a));\n  };\n\n  var result = promiEvent(promise.then(function (resolved) {\n    // Emit default completion events and resolve result.\n    result.emit('done', resolved);\n    result.emit('settled');\n    return resolved;\n  }, function (err) {\n    // Emit default error events and re-throw.\n    result.emit('error', err);\n    result.emit('settled');\n    throw err;\n  }));\n  return result;\n}\n/**\n * Creates a `Promise` with an **async executor** that automatically catches\n * errors occurring within the executor. Nesting promises in this way is usually\n * deemed an _anti-pattern_, but it's useful and clean when promisifying the\n * event-based code that's inherent to JSON RPC.\n *\n * So, here we solve the issue of nested promises by ensuring that no errors\n * mistakenly go unhandled!\n */\n\nexport function createPromise(executor) {\n  return new Promise(function (resolve, reject) {\n    var result = executor(resolve, reject);\n    Promise.resolve(result).catch(reject);\n  });\n}","map":{"version":3,"sources":["../../../src/util/promise-tools.ts"],"names":[],"mappings":"AAAA,SAAyC,kBAAzC,QAAmE,UAAnE;AA0CA,IAAM,eAAe,GAAG,MAAM,CAAC,cAAD,CAA9B;AAEA;;AAEG;;AACH,OAAM,SAAU,YAAV,CAAuB,KAAvB,EAAiC;AACrC,SAAO,CAAC,CAAC,KAAK,CAAC,eAAD,CAAd;AACD;AAED;;;AAGG;;AACH,OAAM,SAAU,gBAAV,CACJ,QADI,EACmC;AAEvC,MAAM,OAAO,GAAG,aAAa,CAAC,QAAD,CAA7B;;AACM,MAAA,EAAA,GAAA,kBAAA,EAAA;AAAA,MAAE,wBAAA,GAAA,EAAA,CAAA,wBAAF;AAAA,MAA4B,2BAAA,GAAA,EAAA,CAAA,2BAA5B,CAHiC,CAOvC;AACA;;;AACA,MAAM,UAAU,GAAG,MAAM,CAAC,cAAD,CAAzB;AACA,MAAM,WAAW,GAAG,MAAM,CAAC,eAAD,CAA1B;AACA,MAAM,aAAa,GAAG,MAAM,CAAC,iBAAD,CAA5B;AAEA;;;AAGG;;AACH,MAAM,2BAA2B,GAAG,UAClC,MADkC,EAElC,MAFkC,EAEd;AACjB,WAAA,YAAA;AAAC,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,QAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACJ,UAAM,WAAW,GAAI,MAAc,CAAC,MAAD,CAAd,CAAuB,KAAvB,CAA6B,MAA7B,EAAqC,IAArC,CAArB;AACA,aAAO,UAAU,CAAC,WAAD,CAAjB;AAFG,KAAA;AAGJ,GAND;AAQA;;;AAGG;;;AACH,MAAM,UAAU,GAAG,UAAC,MAAD,EAAY;;;AAC7B,WAAO,MAAM,CAAC,MAAP,CAAc,MAAd,GAAoB,EAAA,GAAA,EAAA,EACzB,EAAA,CAAC,eAAD,CAAA,GAAmB,IADM,EAGzB,EAAA,CAAC,UAAD,CAAA,GAAc,MAAM,CAAC,UAAD,CAAN,IAAsB,MAAM,CAAC,IAHlB,EAIzB,EAAA,CAAC,WAAD,CAAA,GAAe,MAAM,CAAC,WAAD,CAAN,IAAuB,MAAM,CAAC,KAJpB,EAKzB,EAAA,CAAC,aAAD,CAAA,GAAiB,MAAM,CAAC,aAAD,CAAN,IAAyB,MAAM,CAAC,OALxB,EAOzB,EAAA,CAAA,IAAA,GAAM,2BAA2B,CAAC,UAAD,EAAa,MAAb,CAPR,EAQzB,EAAA,CAAA,KAAA,GAAO,2BAA2B,CAAC,WAAD,EAAc,MAAd,CART,EASzB,EAAA,CAAA,OAAA,GAAS,2BAA2B,CAAC,aAAD,EAAgB,MAAhB,CATX,EAWzB,EAAA,CAAA,EAAA,GAAI,2BAA2B,CAAC,IAAD,EAAO,MAAP,CAXN,EAYzB,EAAA,CAAA,IAAA,GAAM,2BAA2B,CAAC,MAAD,EAAS,MAAT,CAZR,EAazB,EAAA,CAAA,WAAA,GAAa,2BAA2B,CAAC,aAAD,EAAgB,MAAhB,CAbf,EAezB,EAAA,CAAA,GAAA,GAAK,2BAA2B,CAAC,KAAD,EAAQ,MAAR,CAfP,EAgBzB,EAAA,CAAA,cAAA,GAAgB,2BAA2B,CAAC,gBAAD,EAAmB,MAAnB,CAhBlB,EAiBzB,EAAA,CAAA,kBAAA,GAAoB,2BAA2B,CAAC,oBAAD,EAAuB,MAAvB,CAjBtB,EAmBzB,EAAA,CAAA,IAAA,GAAM,wBAAwB,CAAC,MAAD,CAnBL,EAoBzB,EAAA,CAAA,UAAA,GAAY,wBAAwB,CAAC,YAAD,CApBX,EAqBzB,EAAA,CAAA,SAAA,GAAW,wBAAwB,CAAC,WAAD,CArBV,EAsBzB,EAAA,CAAA,aAAA,GAAe,wBAAwB,CAAC,eAAD,CAtBd,EAuBzB,EAvBK,EAAP;AAwBD,GAzBD;;AA2BA,MAAM,MAAM,GAAG,UAAU,CACvB,OAAO,CAAC,IAAR,CACE,UAAC,QAAD,EAAS;AACP;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,QAApB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,SAAZ;AACA,WAAO,QAAP;AACD,GANH,EAQE,UAAC,GAAD,EAAI;AACF;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,GAArB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,SAAZ;AACA,UAAM,GAAN;AACD,GAbH,CADuB,CAAzB;AAkBA,SAAO,MAAP;AACD;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAU,aAAV,CAAiC,QAAjC,EAAwE;AAC5E,SAAO,IAAI,OAAJ,CAAqB,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC1C,QAAM,MAAM,GAAG,QAAQ,CAAC,OAAD,EAAU,MAAV,CAAvB;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,MAAhB,EAAwB,KAAxB,CAA8B,MAA9B;AACD,GAHM,CAAP;AAID","sourceRoot":"","sourcesContent":["import { createTypedEmitter } from './events';\nvar promiEventBrand = Symbol('isPromiEvent');\n/**\n * Returns `true` if the given `value` is a `PromiEvent`.\n */\nexport function isPromiEvent(value) {\n    return !!value[promiEventBrand];\n}\n/**\n * Create a native JavaScript `Promise` overloaded with strongly-typed methods\n * from `EventEmitter`.\n */\nexport function createPromiEvent(executor) {\n    var promise = createPromise(executor);\n    var _a = createTypedEmitter(), createBoundEmitterMethod = _a.createBoundEmitterMethod, createChainingEmitterMethod = _a.createChainingEmitterMethod;\n    // We save the original `Promise` methods to the following symbols so we can\n    // access them internally.\n    var thenSymbol = Symbol('Promise.then');\n    var catchSymbol = Symbol('Promise.catch');\n    var finallySymbol = Symbol('Promise.finally');\n    /**\n     * Ensures the next object in the `PromiEvent` chain is overloaded with\n     * `EventEmitter` methods.\n     */\n    var createChainingPromiseMethod = function (method, source) { return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var nextPromise = source[method].apply(source, args);\n        return promiEvent(nextPromise);\n    }; };\n    /**\n     * Builds a `PromiEvent` by assigning `EventEmitter` methods to a native\n     * `Promise` object.\n     */\n    var promiEvent = function (source) {\n        var _a;\n        return Object.assign(source, (_a = {},\n            _a[promiEventBrand] = true,\n            _a[thenSymbol] = source[thenSymbol] || source.then,\n            _a[catchSymbol] = source[catchSymbol] || source.catch,\n            _a[finallySymbol] = source[finallySymbol] || source.finally,\n            _a.then = createChainingPromiseMethod(thenSymbol, source),\n            _a.catch = createChainingPromiseMethod(catchSymbol, source),\n            _a.finally = createChainingPromiseMethod(finallySymbol, source),\n            _a.on = createChainingEmitterMethod('on', source),\n            _a.once = createChainingEmitterMethod('once', source),\n            _a.addListener = createChainingEmitterMethod('addListener', source),\n            _a.off = createChainingEmitterMethod('off', source),\n            _a.removeListener = createChainingEmitterMethod('removeListener', source),\n            _a.removeAllListeners = createChainingEmitterMethod('removeAllListeners', source),\n            _a.emit = createBoundEmitterMethod('emit'),\n            _a.eventNames = createBoundEmitterMethod('eventNames'),\n            _a.listeners = createBoundEmitterMethod('listeners'),\n            _a.listenerCount = createBoundEmitterMethod('listenerCount'),\n            _a));\n    };\n    var result = promiEvent(promise.then(function (resolved) {\n        // Emit default completion events and resolve result.\n        result.emit('done', resolved);\n        result.emit('settled');\n        return resolved;\n    }, function (err) {\n        // Emit default error events and re-throw.\n        result.emit('error', err);\n        result.emit('settled');\n        throw err;\n    }));\n    return result;\n}\n/**\n * Creates a `Promise` with an **async executor** that automatically catches\n * errors occurring within the executor. Nesting promises in this way is usually\n * deemed an _anti-pattern_, but it's useful and clean when promisifying the\n * event-based code that's inherent to JSON RPC.\n *\n * So, here we solve the issue of nested promises by ensuring that no errors\n * mistakenly go unhandled!\n */\nexport function createPromise(executor) {\n    return new Promise(function (resolve, reject) {\n        var result = executor(resolve, reject);\n        Promise.resolve(result).catch(reject);\n    });\n}\n//# sourceMappingURL=promise-tools.js.map"]},"metadata":{},"sourceType":"module"}