{"ast":null,"code":"import { classNames } from './class-names.js';\n/**\r\n * Calls all functions in the order they were chained with the same arguments.\r\n *\r\n * Based on `chain` utility from `@react-aria/utils`\r\n *\r\n * @see the LICENSE file at the root of this source tree:\r\n *   https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/chain.ts\r\n *\r\n * Modifications from original source: none\r\n */\n\nfunction chain(...callbacks) {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') callback(...args);\n    }\n  };\n}\n/**\r\n * Merges multiple props objects together. Event handlers are chained and\r\n * classNames are combined For all other props, the latest prop object overrides\r\n * earlier ones.\r\n *\r\n * Based on `mergeProps` utility from `@react-aria/utils`\r\n *\r\n * @see the LICENSE file at the root of this source tree:\r\n *   https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts\r\n *\r\n * Modifications from original source:\r\n *   - Filters `...args` to remove falsey values\r\n *   - Removes `UNSAFE_className` compatibility\r\n *   - Removes dependency on `clsx` NPM package\r\n *   - Removes `id` merging\r\n *   - Adds `style` merging\r\n */\n\n\nfunction mergeProps(...args) {\n  var _a, _b;\n\n  const argsFiltered = args.filter(Boolean);\n  const result = {};\n\n  for (const props of argsFiltered) {\n    for (const key in result) {\n      if (/^on[A-Z]/.test(key) && typeof result[key] === 'function' && typeof props[key] === 'function') {\n        // Chain event handlers\n        result[key] = chain(result[key], props[key]);\n      } else if (key === 'className') {\n        // Merge class names\n        result[key] = classNames([result.className, props.className]);\n      } else if (key === 'style' && typeof props[key] === 'object') {\n        result[key] = Object.assign(Object.assign({}, (_a = result[key]) !== null && _a !== void 0 ? _a : {}), (_b = props[key]) !== null && _b !== void 0 ? _b : {});\n      } else {\n        // Override others\n        result[key] = props[key] !== undefined ? props[key] : result[key];\n      }\n    } // Add props from B that are not in A\n\n\n    for (const key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key];\n      }\n    }\n  }\n\n  return result;\n}\n\nexport { chain, mergeProps };","map":{"version":3,"sources":["../../../src/libs/merge-props.ts"],"names":[],"mappings":";AAEA;;;;;;;;;;;SAUgB,K,CAAM,GAAG,S,EAAgB;AACvC,SAAO,CAAC,GAAG,IAAJ,KAAe;AACpB,SAAK,MAAM,QAAX,IAAuB,SAAvB,EAAkC;AAChC,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC,QAAQ,CAAC,GAAG,IAAJ,CAAR;AACrC;AACF,GAJD;AAKD;AAED;;;;;;;;;;;;;;;;;;;SAiBgB,U,CAA2E,GAAG,I,EAAO;;;AACnG,QAAM,YAAY,GAAG,IAAI,CAAC,MAAL,CAAY,OAAZ,CAArB;AACA,QAAM,MAAM,GAAwB,EAApC;;AAEA,OAAK,MAAM,KAAX,IAAoB,YAApB,EAAkC;AAChC,SAAK,MAAM,GAAX,IAAkB,MAAlB,EAA0B;AACxB,UAAI,WAAW,IAAX,CAAgB,GAAhB,KAAwB,OAAO,MAAM,CAAC,GAAD,CAAb,KAAuB,UAA/C,IAA6D,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,UAAvF,EAAmG;;AAEjG,QAAA,MAAM,CAAC,GAAD,CAAN,GAAc,KAAK,CAAC,MAAM,CAAC,GAAD,CAAP,EAAc,KAAK,CAAC,GAAD,CAAnB,CAAnB;AACD,OAHD,MAGO,IAAI,GAAG,KAAK,WAAZ,EAAyB;;AAE9B,QAAA,MAAM,CAAC,GAAD,CAAN,GAAc,UAAU,CAAC,CAAC,MAAM,CAAC,SAAR,EAAmB,KAAK,CAAC,SAAzB,CAAD,CAAxB;AACD,OAHM,MAGA,IAAI,GAAG,KAAK,OAAR,IAAmB,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,QAA7C,EAAuD;AAC5D,QAAA,MAAM,CAAC,GAAD,CAAN,GAAW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,CAAA,EAAA,GAAS,MAAM,CAAC,GAAD,CAAf,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,EAApB,GAAwB,EAAxB,CAAA,EAA0B,CAAA,EAAA,GAAO,KAAK,CAAC,GAAD,CAAZ,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,EAA/C,CAAX;AACD,OAFM,MAEA;;AAEL,QAAA,MAAM,CAAC,GAAD,CAAN,GAAc,KAAK,CAAC,GAAD,CAAL,KAAe,SAAf,GAA2B,KAAK,CAAC,GAAD,CAAhC,GAAwC,MAAM,CAAC,GAAD,CAA5D;AACD;AACF,KAd+B,C;;;AAiBhC,SAAK,MAAM,GAAX,IAAkB,KAAlB,EAAyB;AACvB,UAAI,MAAM,CAAC,GAAD,CAAN,KAAgB,SAApB,EAA+B;AAC7B,QAAA,MAAM,CAAC,GAAD,CAAN,GAAc,KAAK,CAAC,GAAD,CAAnB;AACD;AACF;AACF;;AAED,SAAO,MAAP;AACF","sourcesContent":["import { classNames } from './class-names';\n\n/**\n * Calls all functions in the order they were chained with the same arguments.\n *\n * Based on `chain` utility from `@react-aria/utils`\n *\n * @see the LICENSE file at the root of this source tree:\n *   https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/chain.ts\n *\n * Modifications from original source: none\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') callback(...args);\n    }\n  };\n}\n\n/**\n * Merges multiple props objects together. Event handlers are chained and\n * classNames are combined For all other props, the latest prop object overrides\n * earlier ones.\n *\n * Based on `mergeProps` utility from `@react-aria/utils`\n *\n * @see the LICENSE file at the root of this source tree:\n *   https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts\n *\n * Modifications from original source:\n *   - Filters `...args` to remove falsey values\n *   - Removes `UNSAFE_className` compatibility\n *   - Removes dependency on `clsx` NPM package\n *   - Removes `id` merging\n *   - Adds `style` merging\n */\nexport function mergeProps<T extends (Record<string, any> | undefined | null | boolean)[]>(...args: T) {\n  const argsFiltered = args.filter(Boolean) as Record<string, any>[];\n  const result: Record<string, any> = {};\n\n  for (const props of argsFiltered) {\n    for (const key in result) {\n      if (/^on[A-Z]/.test(key) && typeof result[key] === 'function' && typeof props[key] === 'function') {\n        // Chain event handlers\n        result[key] = chain(result[key], props[key]);\n      } else if (key === 'className') {\n        // Merge class names\n        result[key] = classNames([result.className, props.className]);\n      } else if (key === 'style' && typeof props[key] === 'object') {\n        result[key] = { ...(result[key] ?? {}), ...(props[key] ?? {}) };\n      } else {\n        // Override others\n        result[key] = props[key] !== undefined ? props[key] : result[key];\n      }\n    }\n\n    // Add props from B that are not in A\n    for (const key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key];\n      }\n    }\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}