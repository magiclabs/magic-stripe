{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMedia = createMedia;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _DynamicResponsive = require(\"./DynamicResponsive\");\n\nvar _MediaQueries = require(\"./MediaQueries\");\n\nvar _Utils = require(\"./Utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your application’s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\n\n\nfunction createMedia(config) {\n  var _class, _temp;\n\n  var mediaQueries = new _MediaQueries.MediaQueries(config.breakpoints, config.interactions || {});\n  var DynamicResponsive = (0, _DynamicResponsive.createResponsiveComponents)();\n\n  var MediaContext = _react.default.createContext({});\n\n  MediaContext.displayName = \"Media.Context\";\n\n  var MediaParentContext = _react.default.createContext({\n    hasParentMedia: false,\n    breakpointProps: {}\n  });\n\n  MediaContext.displayName = \"MediaParent.Context\";\n\n  var MediaContextProvider = function MediaContextProvider(_ref) {\n    var disableDynamicMediaQueries = _ref.disableDynamicMediaQueries,\n        onlyMatch = _ref.onlyMatch,\n        children = _ref.children;\n\n    if (disableDynamicMediaQueries) {\n      return _react.default.createElement(MediaContext.Provider, {\n        value: {\n          onlyMatch: onlyMatch\n        }\n      }, children);\n    } else {\n      return _react.default.createElement(DynamicResponsive.Provider, {\n        mediaQueries: mediaQueries.dynamicResponsiveMediaQueries,\n        initialMatchingMediaQueries: (0, _Utils.intersection)(mediaQueries.mediaQueryTypes, onlyMatch)\n      }, _react.default.createElement(DynamicResponsive.Consumer, null, function (matches) {\n        var matchingMediaQueries = Object.keys(matches).filter(function (key) {\n          return matches[key];\n        });\n        return _react.default.createElement(MediaContext.Provider, {\n          value: {\n            onlyMatch: (0, _Utils.intersection)(matchingMediaQueries, onlyMatch)\n          }\n        }, children);\n      }));\n    }\n  };\n\n  var Media = (_temp = _class = /*#__PURE__*/function (_React$Component) {\n    _inherits(Media, _React$Component);\n\n    function Media(props) {\n      var _this;\n\n      _classCallCheck(this, Media);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Media).call(this, props));\n      validateProps(props);\n      return _this;\n    }\n\n    _createClass(Media, [{\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n\n        var props = this.props;\n\n        var children = props.children,\n            passedClassName = props.className,\n            interaction = props.interaction,\n            breakpointProps = _objectWithoutProperties(props, [\"children\", \"className\", \"interaction\"]);\n\n        return _react.default.createElement(MediaParentContext.Consumer, null, function (mediaParentContext) {\n          return _react.default.createElement(MediaParentContext.Provider, {\n            value: {\n              hasParentMedia: true,\n              breakpointProps: breakpointProps\n            }\n          }, _react.default.createElement(MediaContext.Consumer, null, function () {\n            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n                onlyMatch = _ref2.onlyMatch;\n\n            var className;\n\n            if (props.interaction) {\n              className = (0, _Utils.createClassName)(\"interaction\", props.interaction);\n            } else {\n              if (props.at) {\n                var largestBreakpoint = mediaQueries.breakpoints.largestBreakpoint;\n\n                if (props.at === largestBreakpoint) {\n                  // TODO: We should look into making React’s __DEV__ available\n                  //       and have webpack completely compile these away.\n                  var ownerName = null;\n\n                  try {\n                    var owner = _this2._reactInternalFiber._debugOwner.type;\n                    ownerName = owner.displayName || owner.name;\n                  } catch (err) {// no-op\n                  }\n\n                  console.warn(\"[@artsy/fresnel] \" + \"`at` is being used with the largest breakpoint. \" + \"Consider using `<Media greaterThanOrEqual=\" + \"\\\"\".concat(largestBreakpoint, \"\\\">` to account for future \") + \"breakpoint definitions outside of this range.\".concat(ownerName ? \" It is being used in the \".concat(ownerName, \" component.\") : \"\"));\n                }\n              }\n\n              var type = (0, _Utils.propKey)(breakpointProps);\n              var breakpoint = breakpointProps[type];\n              className = (0, _Utils.createClassName)(type, breakpoint);\n            }\n\n            var doesMatchParent = !mediaParentContext.hasParentMedia || (0, _Utils.intersection)(mediaQueries.breakpoints.toVisibleAtBreakpointSet(mediaParentContext.breakpointProps), mediaQueries.breakpoints.toVisibleAtBreakpointSet(breakpointProps)).length > 0;\n            var renderChildren = doesMatchParent && (onlyMatch === undefined || mediaQueries.shouldRenderMediaQuery(_objectSpread({}, breakpointProps, {\n              interaction: interaction\n            }), onlyMatch));\n\n            if (props.children instanceof Function) {\n              return props.children(className, renderChildren);\n            } else {\n              return _react.default.createElement(\"div\", {\n                className: \"fresnel-container \".concat(className, \" \").concat(passedClassName),\n                suppressHydrationWarning: !renderChildren\n              }, renderChildren ? props.children : null);\n            }\n          }));\n        });\n      }\n    }]);\n\n    return Media;\n  }(_react.default.Component), _defineProperty(_class, \"defaultProps\", {\n    className: \"\"\n  }), _defineProperty(_class, \"contextType\", MediaParentContext), _temp);\n  return {\n    Media: Media,\n    MediaContextProvider: MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: _toConsumableArray(mediaQueries.breakpoints.sortedBreakpoints),\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps: mediaQueries.breakpoints.valuesWithBreakpointProps\n  };\n}\n\nvar MutuallyExclusiveProps = _MediaQueries.MediaQueries.validKeys();\n\nfunction validateProps(props) {\n  var selectedProps = Object.keys(props).filter(function (prop) {\n    return MutuallyExclusiveProps.includes(prop);\n  });\n\n  if (selectedProps.length < 1) {\n    throw new Error(\"1 of \".concat(MutuallyExclusiveProps.join(\", \"), \" is required.\"));\n  } else if (selectedProps.length > 1) {\n    throw new Error(\"Only 1 of \".concat(selectedProps.join(\", \"), \" is allowed at a time.\"));\n  }\n}","map":{"version":3,"sources":["../src/Media.tsx"],"names":["mediaQueries","MediaQueries","config","DynamicResponsive","MediaContext","React","MediaParentContext","hasParentMedia","breakpointProps","MediaContextProvider","disableDynamicMediaQueries","onlyMatch","children","matchingMediaQueries","matches","Media","validateProps","className","props","passedClassName","interaction","largestBreakpoint","ownerName","owner","console","type","breakpoint","doesMatchParent","mediaParentContext","renderChildren","createMediaStyle","SortedBreakpoints","findBreakpointAtWidth","findBreakpointsForWidths","valuesWithBreakpointProps","MutuallyExclusiveProps","selectedProps"],"mappings":"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","sourcesContent":["// tslint:disable:jsdoc-format\n\nimport React from \"react\"\nimport { createResponsiveComponents } from \"./DynamicResponsive\"\nimport { MediaQueries } from \"./MediaQueries\"\nimport { intersection, propKey, createClassName } from \"./Utils\"\nimport { BreakpointConstraint } from \"./Breakpoints\"\n\n/**\n * A render prop that can be used to render a different container element than\n * the default `div`.\n *\n * @see {@link MediaProps.children}.\n */\nexport type RenderProp = (\n  className: string,\n  renderChildren: boolean\n) => React.ReactNode\n\n// TODO: All of these props should be mutually exclusive. Using a union should\n//       probably be made possible by https://github.com/Microsoft/TypeScript/pull/27408.\nexport interface MediaBreakpointProps<BreakpointKey = string> {\n  /**\n   * Children will only be shown if the viewport matches the specified\n   * breakpoint. That is, a viewport width that’s higher than the configured\n   * breakpoint value, but lower than the value of the next breakpoint, if any\n   * larger breakpoints exist at all.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width between 0 and 768\n     <Media at=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width between 768 and 1024\n     <Media at=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width over 1024\n     <Media at=\"md\">ohai</Media>\n     ```\n   *\n   */\n  at?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is smaller than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n    // Matches a viewport that has a width from 0 to 767\n     <Media lessThan=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media lessThan=\"md\">ohai</Media>\n     ```\n   *\n   */\n  lessThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater than the specified\n   * breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThan=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThan=\"sm\">ohai</Media>\n     ```\n   *\n   */\n  greaterThan?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is greater or equal to the\n   * specified breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to infinity\n     <Media greaterThanOrEqual=\"xs\">ohai</Media>\n\n     // Matches a viewport that has a width from 768 to infinity\n     <Media greaterThanOrEqual=\"sm\">ohai</Media>\n\n     // Matches a viewport that has a width from 1024 to infinity\n     <Media greaterThanOrEqual=\"md\">ohai</Media>\n     ```\n   *\n   */\n  greaterThanOrEqual?: BreakpointKey\n\n  /**\n   * Children will only be shown if the viewport is between the specified\n   * breakpoints. That is, a viewport width that’s higher than or equal to the\n   * small breakpoint value, but lower than the value of the large breakpoint.\n   *\n   * @example\n\n     ```tsx\n     // With breakpoints defined like these\n     { xs: 0, sm: 768, md: 1024 }\n\n     // Matches a viewport that has a width from 0 to 767\n     <Media between={[\"xs\", \"sm\"]}>ohai</Media>\n\n     // Matches a viewport that has a width from 0 to 1023\n     <Media between={[\"xs\", \"md\"]}>ohai</Media>\n     ```\n   *\n   */\n  between?: [BreakpointKey, BreakpointKey]\n}\n\nexport interface MediaProps<BreakpointKey, Interaction>\n  extends MediaBreakpointProps<BreakpointKey> {\n  /**\n   * Children will only be shown if the interaction query matches.\n   *\n   * @example\n\n     ```tsx\n     // With interactions defined like these\n     { hover: \"(hover: hover)\" }\n\n     // Matches an input device that is capable of hovering\n     <Media interaction=\"hover\">ohai</Media>\n     ```\n   */\n  interaction?: Interaction\n\n  /**\n   * The component(s) that should conditionally be shown, depending on the media\n   * query matching.\n   *\n   * In case a different element is preferred, a render prop can be provided\n   * that receives the class-name it should use to have the media query styling\n   * applied.\n   *\n   * Additionally, the render prop receives a boolean that indicates wether or\n   * not its children should be rendered, which will be `false` if the media\n   * query is not included in the `onlyMatch` list. Use this flag if your\n   * component’s children may be expensive to render and you want to avoid any\n   * unnecessary work.\n   * (@see {@link MediaContextProviderProps.onlyMatch} for details)\n   *\n   * @example\n   *\n     ```tsx\n     const Component = () => (\n       <Media greaterThan=\"xs\">\n         {(className, renderChildren) => (\n           <span className={className}>\n             {renderChildren && \"ohai\"}\n           </span>\n         )}\n       </Media>\n     )\n     ```\n   *\n   */\n  children: React.ReactNode | RenderProp\n\n  /**\n   * Additional classNames to passed down and applied to Media container\n   */\n  className?: string\n}\n\nexport interface MediaContextProviderProps<M> {\n  /**\n   * This list of breakpoints and interactions can be used to limit the rendered\n   * output to these.\n   *\n   * For instance, when a server knows for some user-agents that certain\n   * breakpoints will never apply, omitting them altogether will lower the\n   * rendered byte size.\n   */\n  onlyMatch?: M[]\n\n  /**\n   * Disables usage of browser MediaQuery API to only render at the current\n   * breakpoint.\n   *\n   * Use this with caution, as disabling this means React components for all\n   * breakpoints will be mounted client-side and all associated life-cycle hooks\n   * will be triggered, which could lead to unintended side-effects.\n   */\n  disableDynamicMediaQueries?: boolean\n}\n\nexport interface CreateMediaConfig {\n  /**\n   * The breakpoint definitions for your application. Width definitions should\n   * start at 0.\n   *\n   * @see {@link createMedia}\n   */\n  breakpoints: { [key: string]: number }\n\n  /**\n   * The interaction definitions for your application.\n   */\n  interactions?: { [key: string]: string }\n}\n\nexport interface CreateMediaResults<BreakpointKey, Interactions> {\n  /**\n   * The React component that you use throughout your application.\n   *\n   * @see {@link MediaBreakpointProps}\n   */\n  Media: React.ComponentType<MediaProps<BreakpointKey, Interactions>>\n\n  /**\n   * The React Context provider component that you use to constrain rendering of\n   * breakpoints to a set list and to enable client-side dynamic constraining.\n   *\n   * @see {@link MediaContextProviderProps}\n   */\n  MediaContextProvider: React.ComponentType<\n    MediaContextProviderProps<BreakpointKey | Interactions>\n  >\n\n  /**\n   * Generates a set of CSS rules that you should include in your application’s\n   * styling to enable the hiding behaviour of your `Media` component uses.\n   */\n  createMediaStyle(breakpointKeys?: BreakpointConstraint[]): string\n\n  /**\n   * A list of your application’s breakpoints sorted from small to large.\n   */\n  SortedBreakpoints: BreakpointKey[]\n\n  /**\n   * Creates a list of your application’s breakpoints that support the given\n   * widths and everything in between.\n   */\n  findBreakpointsForWidths(\n    fromWidth: number,\n    throughWidth: number\n  ): BreakpointKey[] | undefined\n\n  /**\n   * Finds the breakpoint that matches the given width.\n   */\n  findBreakpointAtWidth(width: number): BreakpointKey | undefined\n\n  /**\n   * Maps a list of values for various breakpoints to props that can be used\n   * with the `Media` component.\n   *\n   * The values map to corresponding indices in the sorted breakpoints array. If\n   * less values are specified than the number of breakpoints your application\n   * has, the last value will be applied to all subsequent breakpoints.\n   */\n  valuesWithBreakpointProps<SizeValue>(\n    values: SizeValue[]\n  ): Array<[SizeValue, MediaBreakpointProps<BreakpointKey>]>\n}\n\n/**\n * This is used to generate a Media component, its context provider, and CSS\n * rules based on your application’s breakpoints and interactions.\n *\n * Note that the interaction queries are entirely up to you to define and they\n * should be written in such a way that they match when you want the element to\n * be hidden.\n *\n * @example\n *\n   ```tsx\n   const MyAppMedia = createMedia({\n     breakpoints: {\n       xs: 0,\n       sm: 768,\n       md: 900\n       lg: 1024,\n       xl: 1192,\n     },\n     interactions: {\n       hover: `not all and (hover:hover)`\n     },\n   })\n\n   export const Media = MyAppMedia.Media\n   export const MediaContextProvider = MyAppMedia.MediaContextProvider\n   export const createMediaStyle = MyAppMedia.createMediaStyle\n   ```\n *\n */\nexport function createMedia<\n  MediaConfig extends CreateMediaConfig,\n  BreakpointKey extends keyof MediaConfig[\"breakpoints\"],\n  Interaction extends keyof MediaConfig[\"interactions\"]\n>(config: MediaConfig): CreateMediaResults<BreakpointKey, Interaction> {\n  const mediaQueries = new MediaQueries<BreakpointKey>(\n    config.breakpoints,\n    config.interactions || {}\n  )\n\n  const DynamicResponsive = createResponsiveComponents()\n\n  const MediaContext = React.createContext<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  >({})\n  MediaContext.displayName = \"Media.Context\"\n\n  const MediaParentContext = React.createContext<{\n    hasParentMedia: boolean\n    breakpointProps: MediaBreakpointProps<BreakpointKey>\n  }>({ hasParentMedia: false, breakpointProps: {} })\n  MediaContext.displayName = \"MediaParent.Context\"\n\n  const MediaContextProvider: React.SFC<\n    MediaContextProviderProps<BreakpointKey | Interaction>\n  > = ({ disableDynamicMediaQueries, onlyMatch, children }) => {\n    if (disableDynamicMediaQueries) {\n      return (\n        <MediaContext.Provider\n          value={{\n            onlyMatch,\n          }}\n        >\n          {children}\n        </MediaContext.Provider>\n      )\n    } else {\n      return (\n        <DynamicResponsive.Provider\n          mediaQueries={mediaQueries.dynamicResponsiveMediaQueries}\n          initialMatchingMediaQueries={intersection(\n            mediaQueries.mediaQueryTypes,\n            onlyMatch\n          )}\n        >\n          <DynamicResponsive.Consumer>\n            {matches => {\n              const matchingMediaQueries = Object.keys(matches).filter(\n                key => matches[key]\n              )\n              return (\n                <MediaContext.Provider\n                  value={{\n                    onlyMatch: intersection(matchingMediaQueries, onlyMatch),\n                  }}\n                >\n                  {children}\n                </MediaContext.Provider>\n              )\n            }}\n          </DynamicResponsive.Consumer>\n        </DynamicResponsive.Provider>\n      )\n    }\n  }\n\n  const Media = class extends React.Component<\n    MediaProps<BreakpointKey, Interaction>\n  > {\n    constructor(props) {\n      super(props)\n      validateProps(props)\n    }\n\n    static defaultProps = {\n      className: \"\",\n    }\n\n    static contextType = MediaParentContext\n\n    render() {\n      const props = this.props\n      const {\n        children,\n        className: passedClassName,\n        interaction,\n        ...breakpointProps\n      } = props\n      return (\n        <MediaParentContext.Consumer>\n          {mediaParentContext => {\n            return (\n              <MediaParentContext.Provider\n                value={{ hasParentMedia: true, breakpointProps }}\n              >\n                <MediaContext.Consumer>\n                  {({ onlyMatch } = {}) => {\n                    let className: string | null\n                    if (props.interaction) {\n                      className = createClassName(\n                        \"interaction\",\n                        props.interaction\n                      )\n                    } else {\n                      if (props.at) {\n                        const largestBreakpoint =\n                          mediaQueries.breakpoints.largestBreakpoint\n                        if (props.at === largestBreakpoint) {\n                          // TODO: We should look into making React’s __DEV__ available\n                          //       and have webpack completely compile these away.\n                          let ownerName = null\n                          try {\n                            const owner = (this as any)._reactInternalFiber\n                              ._debugOwner.type\n                            ownerName = owner.displayName || owner.name\n                          } catch (err) {\n                            // no-op\n                          }\n\n                          console.warn(\n                            \"[@artsy/fresnel] \" +\n                              \"`at` is being used with the largest breakpoint. \" +\n                              \"Consider using `<Media greaterThanOrEqual=\" +\n                              `\"${largestBreakpoint}\">\\` to account for future ` +\n                              `breakpoint definitions outside of this range.${\n                                ownerName\n                                  ? ` It is being used in the ${ownerName} component.`\n                                  : \"\"\n                              }`\n                          )\n                        }\n                      }\n\n                      const type = propKey(breakpointProps)\n                      const breakpoint = breakpointProps[type]!\n                      className = createClassName(type, breakpoint)\n                    }\n\n                    const doesMatchParent =\n                      !mediaParentContext.hasParentMedia ||\n                      intersection(\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          mediaParentContext.breakpointProps\n                        ),\n                        mediaQueries.breakpoints.toVisibleAtBreakpointSet(\n                          breakpointProps\n                        )\n                      ).length > 0\n                    const renderChildren =\n                      doesMatchParent &&\n                      (onlyMatch === undefined ||\n                        mediaQueries.shouldRenderMediaQuery(\n                          { ...breakpointProps, interaction },\n                          onlyMatch\n                        ))\n\n                    if (props.children instanceof Function) {\n                      return props.children(className, renderChildren)\n                    } else {\n                      return (\n                        <div\n                          className={`fresnel-container ${className} ${passedClassName}`}\n                          suppressHydrationWarning={!renderChildren}\n                        >\n                          {renderChildren ? props.children : null}\n                        </div>\n                      )\n                    }\n                  }}\n                </MediaContext.Consumer>\n              </MediaParentContext.Provider>\n            )\n          }}\n        </MediaParentContext.Consumer>\n      )\n    }\n  }\n\n  return {\n    Media,\n    MediaContextProvider,\n    createMediaStyle: mediaQueries.toStyle,\n    SortedBreakpoints: [...mediaQueries.breakpoints.sortedBreakpoints],\n    findBreakpointAtWidth: mediaQueries.breakpoints.findBreakpointAtWidth,\n    findBreakpointsForWidths: mediaQueries.breakpoints.findBreakpointsForWidths,\n    valuesWithBreakpointProps:\n      mediaQueries.breakpoints.valuesWithBreakpointProps,\n  }\n}\n\nconst MutuallyExclusiveProps: string[] = MediaQueries.validKeys()\n\nfunction validateProps(props) {\n  const selectedProps = Object.keys(props).filter(prop =>\n    MutuallyExclusiveProps.includes(prop)\n  )\n  if (selectedProps.length < 1) {\n    throw new Error(`1 of ${MutuallyExclusiveProps.join(\", \")} is required.`)\n  } else if (selectedProps.length > 1) {\n    throw new Error(\n      `Only 1 of ${selectedProps.join(\", \")} is allowed at a time.`\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}