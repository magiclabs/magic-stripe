import { __rest } from '../../../_virtual/_tslib.js';
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { AnimatePresence, motion } from 'framer-motion';
import { classNames } from '../../../libs/class-names.js';
import 'color';
import 'blueimp-md5';
import '@artsy/fresnel';
import { useTheme } from '../../theme/use-theme.js';
import { forwardRefWrapper } from '../../../libs/forward-ref-wrapper.js';
import composeRefs from '@seznam/compose-react-refs';
import '../../theme/inverse-theme-semantics.js';
import { useIsomorphicLayoutEffect } from '../../../hooks/use-isomorphic-layout-effect.js';
import { ThemeProvider } from '../../theme/theme-provider.js';
import { useSlide } from '../../../hooks/transitions.js';
import { EphemeralPortal } from '../../layout/ephemeral-portal.js';
import { FlexibleDiv } from '../../layout/flexible-div.js';
import { Popper, Manager, Reference } from 'react-popper-2';
import modules_cfa5ac34 from './tooltip.less.js';

/* eslint-disable no-nested-ternary */
/**
 * A low-level tooltip component. Tooltip visibility state should be managed by
 * the consuming component (or you can use `<AnchoredTooltip />`).
 */
const Tooltip = /* @__PURE__ */ forwardRefWrapper('Tooltip', {
    in: false,
    delay: { show: 0, hide: 1000 },
    placement: 'top',
    waitForPointerExit: true,
    arrow: true,
    overflow: false,
}, (props, externalRef) => {
    const { children, anchor, in: inProp, delay, placement, waitForPointerExit, arrow, overflow } = props, otherProps = __rest(props, ["children", "anchor", "in", "delay", "placement", "waitForPointerExit", "arrow", "overflow"]);
    const [shouldShow, setShouldShow] = useState(inProp);
    const [isMouseOverTooltip, setIsMouseOverTooltip] = useState(false);
    const popperUpdate = useRef(null);
    const getSlideProps = useSlide();
    const showDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.show) || 0;
    const hideDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.hide) || 1000;
    // --- Effects
    // Show/hide the tooltip while
    // accounting for the configured delay.
    useEffect(() => {
        let showTimeout;
        let hideTimeout;
        if (inProp && !shouldShow) {
            if (showDelay)
                showTimeout = window.setTimeout(() => setShouldShow(true), showDelay);
            else
                setShouldShow(true);
        }
        else if (!inProp && (!waitForPointerExit ? true : !isMouseOverTooltip) && shouldShow) {
            if (hideDelay)
                hideTimeout = window.setTimeout(() => setShouldShow(false), hideDelay);
            else
                setShouldShow(false);
        }
        return () => {
            if (showTimeout)
                clearTimeout(showTimeout);
            if (hideTimeout)
                clearTimeout(hideTimeout);
        };
    }, [inProp, shouldShow, isMouseOverTooltip, showDelay, hideDelay]);
    // Force-update the underlying Popper.js
    // instance if `shouldShow` changes.
    useIsomorphicLayoutEffect(() => {
        if (popperUpdate.current)
            popperUpdate.current();
    }, [shouldShow]);
    // --- Callbacks
    /**
     * Keep showing the tooltip if mouse enters the content area, if there
     * is a `hideDelay` value set, we also start the timeout. The timeout
     * itself does not hide the tooltip, for that we wait until the mouse
     * leaves the content area (see `handleTooltipContentMouseLeave` below).
     */
    const handleTooltipContentMouseEnter = useCallback(() => {
        setShouldShow(true);
        setIsMouseOverTooltip(true);
    }, []);
    /**
     * Stops showing the tooltip when mouse leaves the content area, while
     * respecting the current `hideDelay` prop value.
     */
    const handleTooltipContentMouseLeave = useCallback(() => {
        setIsMouseOverTooltip(false);
    }, []);
    // --- Rendering
    const tooltip = (React.createElement(Popper, { placement: placement, modifiers: [
            { name: 'offset', enabled: true, options: { offset: [0, 10] } },
            { name: 'preventOverflow', enabled: !overflow },
            { name: 'arrow', options: { padding: 5 } },
        ] }, ({ placement: popperPlacement, ref, style, arrowProps, update }) => {
        popperUpdate.current = update; // Save a reference to `scheduleUpdate`
        return (React.createElement("div", Object.assign({ className: modules_cfa5ac34.Tooltip }, otherProps, { style: style, ref: composeRefs(ref, externalRef) }),
            React.createElement(AnimatePresence, null, shouldShow && (React.createElement(motion.div, Object.assign({}, getSlideProps({
                x: popperPlacement.startsWith('right') ? 5 : popperPlacement.startsWith('left') ? -5 : 0,
                y: popperPlacement.startsWith('bottom') ? 5 : popperPlacement.startsWith('top') ? -5 : 0,
            }), { transition: { duration: 0.2 }, className: classNames([modules_cfa5ac34.content, arrow && modules_cfa5ac34.hasArrow]), "x-placement": popperPlacement, onMouseEnter: handleTooltipContentMouseEnter, onMouseLeave: handleTooltipContentMouseLeave }),
                arrow && React.createElement("div", { className: modules_cfa5ac34.arrow, ref: arrowProps.ref, style: arrowProps.style }),
                React.createElement(FlexibleDiv, { initialDelay: 0.2, onAnimationFrame: update }, children))))));
    }));
    const anchorWithRef = useCallback(({ ref }) => React.createElement("div", { ref: ref }, anchor), [anchor]);
    return (React.createElement("div", { className: modules_cfa5ac34.Tooltip },
        React.createElement(Manager, null,
            React.createElement(Reference, null, anchorWithRef),
            React.createElement(EphemeralPortal, null,
                React.createElement(ThemeProvider, { theme: useTheme() }, tooltip)))));
});

export { Tooltip };
//# sourceMappingURL=tooltip.js.map
