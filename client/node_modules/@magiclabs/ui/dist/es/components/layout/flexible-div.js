import { __awaiter, __rest } from '../../_virtual/_tslib.js';
import React, { useRef, useState, useCallback, useEffect } from 'react';
import { forwardRefWrapper } from '../../libs/forward-ref-wrapper.js';
import composeRefs from '@seznam/compose-react-refs';
import { watchResize } from 'watch-resize';
import { cssTimeToMilliseconds } from '../../libs/css-time-to-milliseconds.js';

/**
 * This component is a container which automatically updates its `height` style
 * property based on the total size of its child nodes. This enables dynamic
 * transitional height behavior.
 */
const FlexibleDiv = /* @__PURE__ */ forwardRefWrapper('FlexibleDiv', {
    initialDelay: 0,
    transition: true,
    applyCSSVariables: {},
    onResize: () => { },
    style: {},
    observerOnly: false,
    autoWidth: false,
    autoHeight: false,
}, (props, externalRef) => {
    // --- Data
    var _a, _b, _c, _d;
    const contentElement = useRef();
    const [height, setHeight] = useState('auto');
    const [width, setWidth] = useState('auto');
    const isMounted = useRef(false);
    const isTransitioning = useRef(false);
    const raf = useRef(null);
    // --- Utilities for handling `watch-resize` observer
    /**
     * Set the `containerElement` ref height based on the given element
     * or `contentElement` ref as a fallback.
     */
    const setContainerElementDimensions = useCallback((domRect) => {
        let rect = domRect;
        if (!rect) {
            if (contentElement.current)
                rect = contentElement.current.getBoundingClientRect();
            else
                return;
        }
        if (!props.autoHeight) {
            const nextHeight = Math.ceil(rect.height);
            if (nextHeight !== height)
                setHeight(`${nextHeight}px`);
        }
        if (!props.autoWidth) {
            const nextWidth = Math.ceil(rect.width);
            if (nextWidth !== width)
                setWidth(`${nextWidth}px`);
        }
    }, [height, width]);
    /**
     * Build styles to transition height.
     */
    const buildTransitionStyles = useCallback((heightOverride, widthOverride) => {
        if (props.transition) {
            let transition = 'height 0.2s ease, width 0.2s ease';
            if (typeof props.transition !== 'boolean') {
                const { duration, timingFunction, delay } = props.transition;
                transition = `height${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
                transition += `, width${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
            }
            const resolvedHeightOverride = heightOverride ? `${Math.ceil(heightOverride)}px` : null;
            const resolvedHeight = typeof height === 'string' ? height : `${Math.ceil(height)}px`;
            const resolvedWidthOverride = widthOverride ? `${Math.ceil(widthOverride)}px` : null;
            const resolvedWidth = typeof width === 'string' ? width : `${Math.ceil(width)}px`;
            return {
                transition,
                height: props.autoHeight ? 'auto' : resolvedHeightOverride || resolvedHeight,
                width: props.autoWidth ? 'auto' : resolvedWidthOverride || resolvedWidth,
                willChange: 'height, width',
            };
        }
        return {
            transition: 'none',
            height: 'auto',
            width: 'auto',
            willChange: 'unset',
        };
    }, [props.transition, height, width]);
    /**
     * Set CSS variables for the generated `transition` and `height` properties.
     */
    const applyCSSVariables = useCallback((heightOverride, widthOverride) => {
        const { element, heightVar, widthVar, transitionVar } = props.applyCSSVariables;
        const transitionStyles = buildTransitionStyles(heightOverride, widthOverride);
        const elementResolved = element || document.documentElement;
        if (heightVar)
            elementResolved.style.setProperty(heightVar, props.autoHeight ? 'auto' : transitionStyles.height);
        if (widthVar)
            elementResolved.style.setProperty(widthVar, props.autoWidth ? 'auto' : transitionStyles.width);
        if (transitionVar)
            elementResolved.style.setProperty(transitionVar, transitionStyles.transition);
    }, [
        (_a = props.applyCSSVariables) === null || _a === void 0 ? void 0 : _a.element,
        (_b = props.applyCSSVariables) === null || _b === void 0 ? void 0 : _b.heightVar,
        (_c = props.applyCSSVariables) === null || _c === void 0 ? void 0 : _c.widthVar,
        (_d = props.applyCSSVariables) === null || _d === void 0 ? void 0 : _d.transitionVar,
    ]);
    /**
     * Create the resize stream and start observing.
     */
    const setupResizeObservable = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        /*
          Under the hood, `watchResize` is creating a nested browsing
          context inside a DOM `<object>`. This nested context has a
          `window` object that provides the stream of "resize" events.
         */
        const destroy = yield watchResize(contentElement.current, (payload) => {
            var _a, _b;
            isTransitioning.current = true;
            setTimeout(() => {
                if (isMounted.current)
                    isTransitioning.current = false;
            }, cssTimeToMilliseconds((_a = props.transition) === null || _a === void 0 ? void 0 : _a.duration) + 100);
            const rect = payload.element.getBoundingClientRect();
            (_b = props.onResize) === null || _b === void 0 ? void 0 : _b.call(props, Object.assign(Object.assign({}, payload), { transitionStyles: buildTransitionStyles(rect.height, rect.width) }));
            applyCSSVariables(rect.height, rect.width);
            if (!props.observerOnly)
                setContainerElementDimensions(rect);
        });
        return destroy;
    }), [setContainerElementDimensions, props.observerOnly, buildTransitionStyles, applyCSSVariables, props.transition]);
    /**
     * Stop observing the resize stream and destroy the subscription (the stream
     * itself will be garbage collected).
     */
    const teardownResizeObservable = useCallback((destroy) => {
        if (destroy)
            destroy();
    }, []);
    // --- React lifecycle
    // Setup/teardown the resize observable on component mount/unmount
    useEffect(() => {
        let destroyResizeListener;
        let timeout;
        isMounted.current = true;
        (() => __awaiter(void 0, void 0, void 0, function* () {
            if (props.initialDelay) {
                timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                    if (!props.observerOnly)
                        setContainerElementDimensions();
                    destroyResizeListener = yield setupResizeObservable();
                }), props.initialDelay);
            }
            else {
                setContainerElementDimensions();
                destroyResizeListener = yield setupResizeObservable();
            }
        }))();
        return () => {
            isMounted.current = false;
            if (timeout)
                clearTimeout(timeout);
            teardownResizeObservable(destroyResizeListener);
        };
    }, []);
    useEffect(() => {
        if (isTransitioning.current && props.onAnimationFrame) {
            const tick = () => {
                raf.current = requestAnimationFrame((...args) => {
                    props.onAnimationFrame(...args);
                    if (isTransitioning.current)
                        tick();
                });
            };
            tick();
        }
        else {
            return () => {
                if (raf.current)
                    cancelAnimationFrame(raf.current);
            };
        }
        return undefined;
    });
    // --- Rendering
    const otherProps = __rest(props, ["children", "style", "initialDelay", "transition", "onResize", "observerOnly", "applyCSSVariables", "onAnimationFrame", "autoWidth", "autoHeight"]);
    return props.observerOnly ? (React.createElement("div", Object.assign({ style: props.style }, otherProps, { ref: composeRefs(contentElement, externalRef) }), props.children)) : (React.createElement("div", Object.assign({ style: Object.assign(Object.assign({ position: 'relative' }, props.style), buildTransitionStyles()) }, otherProps),
        React.createElement("div", { ref: composeRefs(contentElement, externalRef), style: { position: width === 'auto' ? undefined : 'absolute' } }, props.children)));
});

export { FlexibleDiv };
//# sourceMappingURL=flexible-div.js.map
