'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../../_virtual/_tslib.js');
var React = require('react');
var framerMotion = require('framer-motion');
var classNames = require('../../../libs/class-names.js');
require('color');
require('blueimp-md5');
require('@artsy/fresnel');
var useTheme = require('../../theme/use-theme.js');
var forwardRefWrapper = require('../../../libs/forward-ref-wrapper.js');
var composeRefs = require('@seznam/compose-react-refs');
require('../../theme/inverse-theme-semantics.js');
var useIsomorphicLayoutEffect = require('../../../hooks/use-isomorphic-layout-effect.js');
var themeProvider = require('../../theme/theme-provider.js');
var transitions = require('../../../hooks/transitions.js');
var ephemeralPortal = require('../../layout/ephemeral-portal.js');
var flexibleDiv = require('../../layout/flexible-div.js');
var reactPopper2 = require('react-popper-2');
var tooltip = require('./tooltip.less.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var composeRefs__default = /*#__PURE__*/_interopDefaultLegacy(composeRefs);

/* eslint-disable no-nested-ternary */
/**
 * A low-level tooltip component. Tooltip visibility state should be managed by
 * the consuming component (or you can use `<AnchoredTooltip />`).
 */
const Tooltip = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('Tooltip', {
    in: false,
    delay: { show: 0, hide: 1000 },
    placement: 'top',
    waitForPointerExit: true,
    arrow: true,
    overflow: false,
}, (props, externalRef) => {
    const { children, anchor, in: inProp, delay, placement, waitForPointerExit, arrow, overflow } = props, otherProps = _tslib.__rest(props, ["children", "anchor", "in", "delay", "placement", "waitForPointerExit", "arrow", "overflow"]);
    const [shouldShow, setShouldShow] = React.useState(inProp);
    const [isMouseOverTooltip, setIsMouseOverTooltip] = React.useState(false);
    const popperUpdate = React.useRef(null);
    const getSlideProps = transitions.useSlide();
    const showDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.show) || 0;
    const hideDelay = typeof delay === 'number' ? delay : (delay === null || delay === void 0 ? void 0 : delay.hide) || 1000;
    // --- Effects
    // Show/hide the tooltip while
    // accounting for the configured delay.
    React.useEffect(() => {
        let showTimeout;
        let hideTimeout;
        if (inProp && !shouldShow) {
            if (showDelay)
                showTimeout = window.setTimeout(() => setShouldShow(true), showDelay);
            else
                setShouldShow(true);
        }
        else if (!inProp && (!waitForPointerExit ? true : !isMouseOverTooltip) && shouldShow) {
            if (hideDelay)
                hideTimeout = window.setTimeout(() => setShouldShow(false), hideDelay);
            else
                setShouldShow(false);
        }
        return () => {
            if (showTimeout)
                clearTimeout(showTimeout);
            if (hideTimeout)
                clearTimeout(hideTimeout);
        };
    }, [inProp, shouldShow, isMouseOverTooltip, showDelay, hideDelay]);
    // Force-update the underlying Popper.js
    // instance if `shouldShow` changes.
    useIsomorphicLayoutEffect.useIsomorphicLayoutEffect(() => {
        if (popperUpdate.current)
            popperUpdate.current();
    }, [shouldShow]);
    // --- Callbacks
    /**
     * Keep showing the tooltip if mouse enters the content area, if there
     * is a `hideDelay` value set, we also start the timeout. The timeout
     * itself does not hide the tooltip, for that we wait until the mouse
     * leaves the content area (see `handleTooltipContentMouseLeave` below).
     */
    const handleTooltipContentMouseEnter = React.useCallback(() => {
        setShouldShow(true);
        setIsMouseOverTooltip(true);
    }, []);
    /**
     * Stops showing the tooltip when mouse leaves the content area, while
     * respecting the current `hideDelay` prop value.
     */
    const handleTooltipContentMouseLeave = React.useCallback(() => {
        setIsMouseOverTooltip(false);
    }, []);
    // --- Rendering
    const tooltip$1 = (React__default['default'].createElement(reactPopper2.Popper, { placement: placement, modifiers: [
            { name: 'offset', enabled: true, options: { offset: [0, 10] } },
            { name: 'preventOverflow', enabled: !overflow },
            { name: 'arrow', options: { padding: 5 } },
        ] }, ({ placement: popperPlacement, ref, style, arrowProps, update }) => {
        popperUpdate.current = update; // Save a reference to `scheduleUpdate`
        return (React__default['default'].createElement("div", Object.assign({ className: tooltip.default.Tooltip }, otherProps, { style: style, ref: composeRefs__default['default'](ref, externalRef) }),
            React__default['default'].createElement(framerMotion.AnimatePresence, null, shouldShow && (React__default['default'].createElement(framerMotion.motion.div, Object.assign({}, getSlideProps({
                x: popperPlacement.startsWith('right') ? 5 : popperPlacement.startsWith('left') ? -5 : 0,
                y: popperPlacement.startsWith('bottom') ? 5 : popperPlacement.startsWith('top') ? -5 : 0,
            }), { transition: { duration: 0.2 }, className: classNames.classNames([tooltip.default.content, arrow && tooltip.default.hasArrow]), "x-placement": popperPlacement, onMouseEnter: handleTooltipContentMouseEnter, onMouseLeave: handleTooltipContentMouseLeave }),
                arrow && React__default['default'].createElement("div", { className: tooltip.default.arrow, ref: arrowProps.ref, style: arrowProps.style }),
                React__default['default'].createElement(flexibleDiv.FlexibleDiv, { initialDelay: 0.2, onAnimationFrame: update }, children))))));
    }));
    const anchorWithRef = React.useCallback(({ ref }) => React__default['default'].createElement("div", { ref: ref }, anchor), [anchor]);
    return (React__default['default'].createElement("div", { className: tooltip.default.Tooltip },
        React__default['default'].createElement(reactPopper2.Manager, null,
            React__default['default'].createElement(reactPopper2.Reference, null, anchorWithRef),
            React__default['default'].createElement(ephemeralPortal.EphemeralPortal, null,
                React__default['default'].createElement(themeProvider.ThemeProvider, { theme: useTheme.useTheme() }, tooltip$1)))));
});

exports.Tooltip = Tooltip;
//# sourceMappingURL=tooltip.js.map
