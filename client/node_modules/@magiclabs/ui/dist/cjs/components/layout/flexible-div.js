'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.js');
var React = require('react');
var forwardRefWrapper = require('../../libs/forward-ref-wrapper.js');
var composeRefs = require('@seznam/compose-react-refs');
var watchResize = require('watch-resize');
var cssTimeToMilliseconds = require('../../libs/css-time-to-milliseconds.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var composeRefs__default = /*#__PURE__*/_interopDefaultLegacy(composeRefs);

/**
 * This component is a container which automatically updates its `height` style
 * property based on the total size of its child nodes. This enables dynamic
 * transitional height behavior.
 */
const FlexibleDiv = /* @__PURE__ */ forwardRefWrapper.forwardRefWrapper('FlexibleDiv', {
    initialDelay: 0,
    transition: true,
    applyCSSVariables: {},
    onResize: () => { },
    style: {},
    observerOnly: false,
    autoWidth: false,
    autoHeight: false,
}, (props, externalRef) => {
    // --- Data
    var _a, _b, _c, _d;
    const contentElement = React.useRef();
    const [height, setHeight] = React.useState('auto');
    const [width, setWidth] = React.useState('auto');
    const isMounted = React.useRef(false);
    const isTransitioning = React.useRef(false);
    const raf = React.useRef(null);
    // --- Utilities for handling `watch-resize` observer
    /**
     * Set the `containerElement` ref height based on the given element
     * or `contentElement` ref as a fallback.
     */
    const setContainerElementDimensions = React.useCallback((domRect) => {
        let rect = domRect;
        if (!rect) {
            if (contentElement.current)
                rect = contentElement.current.getBoundingClientRect();
            else
                return;
        }
        if (!props.autoHeight) {
            const nextHeight = Math.ceil(rect.height);
            if (nextHeight !== height)
                setHeight(`${nextHeight}px`);
        }
        if (!props.autoWidth) {
            const nextWidth = Math.ceil(rect.width);
            if (nextWidth !== width)
                setWidth(`${nextWidth}px`);
        }
    }, [height, width]);
    /**
     * Build styles to transition height.
     */
    const buildTransitionStyles = React.useCallback((heightOverride, widthOverride) => {
        if (props.transition) {
            let transition = 'height 0.2s ease, width 0.2s ease';
            if (typeof props.transition !== 'boolean') {
                const { duration, timingFunction, delay } = props.transition;
                transition = `height${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
                transition += `, width${duration ? `${duration} ` : ' 0.2s'}${timingFunction ? `${timingFunction} ` : ' ease'}${delay ? `${delay} ` : ' 0s'}`;
            }
            const resolvedHeightOverride = heightOverride ? `${Math.ceil(heightOverride)}px` : null;
            const resolvedHeight = typeof height === 'string' ? height : `${Math.ceil(height)}px`;
            const resolvedWidthOverride = widthOverride ? `${Math.ceil(widthOverride)}px` : null;
            const resolvedWidth = typeof width === 'string' ? width : `${Math.ceil(width)}px`;
            return {
                transition,
                height: props.autoHeight ? 'auto' : resolvedHeightOverride || resolvedHeight,
                width: props.autoWidth ? 'auto' : resolvedWidthOverride || resolvedWidth,
                willChange: 'height, width',
            };
        }
        return {
            transition: 'none',
            height: 'auto',
            width: 'auto',
            willChange: 'unset',
        };
    }, [props.transition, height, width]);
    /**
     * Set CSS variables for the generated `transition` and `height` properties.
     */
    const applyCSSVariables = React.useCallback((heightOverride, widthOverride) => {
        const { element, heightVar, widthVar, transitionVar } = props.applyCSSVariables;
        const transitionStyles = buildTransitionStyles(heightOverride, widthOverride);
        const elementResolved = element || document.documentElement;
        if (heightVar)
            elementResolved.style.setProperty(heightVar, props.autoHeight ? 'auto' : transitionStyles.height);
        if (widthVar)
            elementResolved.style.setProperty(widthVar, props.autoWidth ? 'auto' : transitionStyles.width);
        if (transitionVar)
            elementResolved.style.setProperty(transitionVar, transitionStyles.transition);
    }, [
        (_a = props.applyCSSVariables) === null || _a === void 0 ? void 0 : _a.element,
        (_b = props.applyCSSVariables) === null || _b === void 0 ? void 0 : _b.heightVar,
        (_c = props.applyCSSVariables) === null || _c === void 0 ? void 0 : _c.widthVar,
        (_d = props.applyCSSVariables) === null || _d === void 0 ? void 0 : _d.transitionVar,
    ]);
    /**
     * Create the resize stream and start observing.
     */
    const setupResizeObservable = React.useCallback(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
        /*
          Under the hood, `watchResize` is creating a nested browsing
          context inside a DOM `<object>`. This nested context has a
          `window` object that provides the stream of "resize" events.
         */
        const destroy = yield watchResize.watchResize(contentElement.current, (payload) => {
            var _a, _b;
            isTransitioning.current = true;
            setTimeout(() => {
                if (isMounted.current)
                    isTransitioning.current = false;
            }, cssTimeToMilliseconds.cssTimeToMilliseconds((_a = props.transition) === null || _a === void 0 ? void 0 : _a.duration) + 100);
            const rect = payload.element.getBoundingClientRect();
            (_b = props.onResize) === null || _b === void 0 ? void 0 : _b.call(props, Object.assign(Object.assign({}, payload), { transitionStyles: buildTransitionStyles(rect.height, rect.width) }));
            applyCSSVariables(rect.height, rect.width);
            if (!props.observerOnly)
                setContainerElementDimensions(rect);
        });
        return destroy;
    }), [setContainerElementDimensions, props.observerOnly, buildTransitionStyles, applyCSSVariables, props.transition]);
    /**
     * Stop observing the resize stream and destroy the subscription (the stream
     * itself will be garbage collected).
     */
    const teardownResizeObservable = React.useCallback((destroy) => {
        if (destroy)
            destroy();
    }, []);
    // --- React lifecycle
    // Setup/teardown the resize observable on component mount/unmount
    React.useEffect(() => {
        let destroyResizeListener;
        let timeout;
        isMounted.current = true;
        (() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
            if (props.initialDelay) {
                timeout = setTimeout(() => _tslib.__awaiter(void 0, void 0, void 0, function* () {
                    if (!props.observerOnly)
                        setContainerElementDimensions();
                    destroyResizeListener = yield setupResizeObservable();
                }), props.initialDelay);
            }
            else {
                setContainerElementDimensions();
                destroyResizeListener = yield setupResizeObservable();
            }
        }))();
        return () => {
            isMounted.current = false;
            if (timeout)
                clearTimeout(timeout);
            teardownResizeObservable(destroyResizeListener);
        };
    }, []);
    React.useEffect(() => {
        if (isTransitioning.current && props.onAnimationFrame) {
            const tick = () => {
                raf.current = requestAnimationFrame((...args) => {
                    props.onAnimationFrame(...args);
                    if (isTransitioning.current)
                        tick();
                });
            };
            tick();
        }
        else {
            return () => {
                if (raf.current)
                    cancelAnimationFrame(raf.current);
            };
        }
        return undefined;
    });
    // --- Rendering
    const otherProps = _tslib.__rest(props, ["children", "style", "initialDelay", "transition", "onResize", "observerOnly", "applyCSSVariables", "onAnimationFrame", "autoWidth", "autoHeight"]);
    return props.observerOnly ? (React__default['default'].createElement("div", Object.assign({ style: props.style }, otherProps, { ref: composeRefs__default['default'](contentElement, externalRef) }), props.children)) : (React__default['default'].createElement("div", Object.assign({ style: Object.assign(Object.assign({ position: 'relative' }, props.style), buildTransitionStyles()) }, otherProps),
        React__default['default'].createElement("div", { ref: composeRefs__default['default'](contentElement, externalRef), style: { position: width === 'auto' ? undefined : 'absolute' } }, props.children)));
});

exports.FlexibleDiv = FlexibleDiv;
//# sourceMappingURL=flexible-div.js.map
