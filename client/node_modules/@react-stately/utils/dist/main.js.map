{"mappings":";;;;;;AAcO,SAASA,kBAAT,CACLC,KADK,EAELC,YAFK,EAGLC,QAHK,EAI6D;AAClE,MAAI,CAACC,UAAD,EAAaC,aAAb,IAA8BC,QAAQ,CAACL,KAAK,IAAIC,YAAV,CAA1C;AACA,MAAIK,GAAG,GAAGC,MAAM,CAACP,KAAK,KAAKQ,SAAX,CAAhB;AACA,MAAIC,aAAa,GAAGH,GAAG,CAACI,OAAxB;AACA,MAAIC,YAAY,GAAGX,KAAK,KAAKQ,SAA7B,CAJkE,CAKlE;;AACA,MAAII,QAAQ,GAAGL,MAAM,CAACJ,UAAD,CAArB;;AACA,MAAIM,aAAa,KAAKE,YAAtB,EAAoC;AAClCE,IAAAA,OAAO,CAACC,IAAR,sCAA+CL,aAAa,GAAG,YAAH,GAAkB,cAA9E,cAAmGE,YAAY,GAAG,YAAH,GAAkB,cAAjI;AACD;;AAEDL,EAAAA,GAAG,CAACI,OAAJ,GAAcC,YAAd;AAEA,MAAII,QAAQ,GAAGC,WAAW,CAAC,UAAChB,KAAD,EAAoB;AAAA,sCAATiB,IAAS;AAATA,MAAAA,IAAS;AAAA;;AAC7C,QAAIC,cAAc,GAAG,SAAjBA,cAAiB,CAAClB,KAAD,EAA4B;AAC/C,UAAIE,QAAJ,EAAc;AACZ,YAAI,CAACiB,MAAM,CAACC,EAAP,CAAUR,QAAQ,CAACF,OAAnB,EAA4BV,KAA5B,CAAL,EAAyC;AAAA,6CAFbqB,YAEa;AAFbA,YAAAA,YAEa;AAAA;;AACvCnB,UAAAA,QAAQ,CAACF,KAAD,EAAQ,GAAGqB,YAAX,CAAR;AACD;AACF;;AACD,UAAI,CAACV,YAAL,EAAmB;AACjBC,QAAAA,QAAQ,CAACF,OAAT,GAAmBV,KAAnB;AACD;AACF,KATD;;AAWA,QAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA,UAAIsB,cAAc,GAAG,SAAjBA,cAAiB,CAACC,QAAD,EAA+B;AAAA,2CAAjBC,YAAiB;AAAjBA,UAAAA,YAAiB;AAAA;;AAClD,YAAIC,gBAAgB,GAAGzB,KAAK,CAACW,YAAY,GAAGC,QAAQ,CAACF,OAAZ,GAAsBa,QAAnC,EAA6C,GAAGC,YAAhD,CAA5B;AACAN,QAAAA,cAAc,CAACO,gBAAD,EAAmB,GAAGR,IAAtB,CAAd;;AACA,YAAI,CAACN,YAAL,EAAmB;AACjB,iBAAOc,gBAAP;AACD;;AACD,eAAOF,QAAP;AACD,OAPD;;AAQAnB,MAAAA,aAAa,CAACkB,cAAD,CAAb;AACD,KAfD,MAeO;AACL,UAAI,CAACX,YAAL,EAAmB;AACjBP,QAAAA,aAAa,CAACJ,KAAD,CAAb;AACD;;AACDkB,MAAAA,cAAc,CAAClB,KAAD,EAAQ,GAAGiB,IAAX,CAAd;AACD;AACF,GAjCyB,EAiCvB,CAACN,YAAD,EAAeT,QAAf,CAjCuB,CAA1B,CAbkE,CAgDlE;;AACA,MAAIS,YAAJ,EAAkB;AAChBC,IAAAA,QAAQ,CAACF,OAAT,GAAmBV,KAAnB;AACD,GAFD,MAEO;AACLA,IAAAA,KAAK,GAAGG,UAAR;AACD;;AAED,SAAO,CAACH,KAAD,EAAQe,QAAR,CAAP;AACD;;;;AC1ED;;;;;;;;;;;;AAYA;;;AAGO,SAASW,KAAT,CAAe1B,KAAf,EAA8B2B,GAA9B,EAAuDC,GAAvD,EAAuF;AAAA,MAAzDD,GAAyD;AAAzDA,IAAAA,GAAyD,GAA3C,CAACE,QAA0C;AAAA;;AAAA,MAAhCD,GAAgC;AAAhCA,IAAAA,GAAgC,GAAlBC,QAAkB;AAAA;;AAC5F,MAAIC,QAAQ,GAAGC,IAAI,CAACJ,GAAL,CAASI,IAAI,CAACH,GAAL,CAAS5B,KAAT,EAAgB2B,GAAhB,CAAT,EAA+BC,GAA/B,CAAf;AACA,SAAOE,QAAP;AACD;;;;AAEM,SAASE,eAAT,CAAyBhC,KAAzB,EAAwC2B,GAAxC,EAAqDC,GAArD,EAAkEK,IAAlE,EAAwF;AAC7F,MAAIC,SAAS,GAAI,CAAClC,KAAK,IAAImC,KAAK,CAACR,GAAD,CAAL,GAAa,CAAb,GAAiBA,GAArB,CAAN,IAAmCM,IAApD;AACA,MAAIG,YAAY,GAAGL,IAAI,CAACM,GAAL,CAASH,SAAT,IAAsB,CAAtB,IAA2BD,IAA3B,GACfjC,KAAK,GAAG+B,IAAI,CAACO,IAAL,CAAUJ,SAAV,KAAwBD,IAAI,GAAGF,IAAI,CAACM,GAAL,CAASH,SAAT,CAA/B,CADO,GAEflC,KAAK,GAAGkC,SAFZ;;AAIA,MAAI,CAACC,KAAK,CAACR,GAAD,CAAV,EAAiB;AACf,QAAIS,YAAY,GAAGT,GAAnB,EAAwB;AACtBS,MAAAA,YAAY,GAAGT,GAAf;AACD,KAFD,MAEO,IAAI,CAACQ,KAAK,CAACP,GAAD,CAAN,IAAeQ,YAAY,GAAGR,GAAlC,EAAuC;AAC5CQ,MAAAA,YAAY,GAAGT,GAAG,GAAGI,IAAI,CAACQ,KAAL,CAAW,CAACX,GAAG,GAAGD,GAAP,IAAcM,IAAzB,IAAiCA,IAAtD;AACD;AACF,GAND,MAMO,IAAI,CAACE,KAAK,CAACP,GAAD,CAAN,IAAeQ,YAAY,GAAGR,GAAlC,EAAuC;AAC5CQ,IAAAA,YAAY,GAAGL,IAAI,CAACQ,KAAL,CAAWX,GAAG,GAAGK,IAAjB,IAAyBA,IAAxC;AACD,GAd4F,CAgB7F;;;AACA,MAAIO,MAAM,GAAGP,IAAI,CAACQ,QAAL,EAAb;AACA,MAAIC,KAAK,GAAGF,MAAM,CAACG,OAAP,CAAe,GAAf,CAAZ;AACA,MAAIC,SAAS,GAAGF,KAAK,IAAI,CAAT,GAAaF,MAAM,CAACK,MAAP,GAAgBH,KAA7B,GAAqC,CAArD;;AAEA,MAAIE,SAAS,GAAG,CAAhB,EAAmB;AACjB,QAAIE,GAAG,GAAGf,IAAI,CAACe,GAAL,CAAS,EAAT,EAAaF,SAAb,CAAV;AACAR,IAAAA,YAAY,GAAGL,IAAI,CAACgB,KAAL,CAAWX,YAAY,GAAGU,GAA1B,IAAiCA,GAAhD;AACD;;AAED,SAAOV,YAAP;AACD","sources":["./packages/@react-stately/utils/src/useControlledState.ts","./packages/@react-stately/utils/src/number.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useRef, useState} from 'react';\n\nexport function useControlledState<T>(\n  value: T,\n  defaultValue: T,\n  onChange: (value: T, ...args: any[]) => void\n): [T, (value: T | ((prevState: T) => T), ...args: any[]) => void]  {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n  let ref = useRef(value !== undefined);\n  let wasControlled = ref.current;\n  let isControlled = value !== undefined;\n  // Internal state reference for useCallback\n  let stateRef = useRef(stateValue);\n  if (wasControlled !== isControlled) {\n    console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n  }\n\n  ref.current = isControlled;\n\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(stateRef.current, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        stateRef.current = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? stateRef.current : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, onChange]);\n\n  // If a controlled component's value prop changes, we need to update stateRef\n  if (isControlled) {\n    stateRef.current = value;\n  } else {\n    value = stateValue;\n  }\n\n  return [value, setValue];\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function snapValueToStep(value: number, min: number, max: number, step: number): number {\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder;\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor((max - min) / step) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(max / step) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  let string = step.toString();\n  let index = string.indexOf('.');\n  let precision = index >= 0 ? string.length - index : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    snappedValue = Math.round(snappedValue * pow) / pow;\n  }\n\n  return snappedValue;\n}\n"],"names":["useControlledState","value","defaultValue","onChange","stateValue","setStateValue","useState","ref","useRef","undefined","wasControlled","current","isControlled","stateRef","console","warn","setValue","useCallback","args","onChangeCaller","Object","is","onChangeArgs","updateFunction","oldValue","functionArgs","interceptedValue","clamp","min","max","Infinity","newValue","Math","snapValueToStep","step","remainder","isNaN","snappedValue","abs","sign","floor","string","toString","index","indexOf","precision","length","pow","round"],"version":3,"file":"main.js.map"}