import _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _clsx from "clsx";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
import _react, { useContext, useEffect, useRef, useState } from "react";
import { getInteractionModality, useFocus, useFocusVisible, useFocusWithin, useKeyboard } from "@react-aria/interactions";
import { focusWithoutScrolling, runAfterTransition, useLayoutEffect, mergeProps } from "@react-aria/utils";

/**
 * A utility function that focuses an element while avoiding undesired side effects such
 * as page scrolling and screen reader issues with CSS transitions.
 */
export function focusSafely(element) {
  // If the user is interacting with a virtual cursor, e.g. screen reader, then
  // wait until after any animated transitions that are currently occurring on
  // the page before shifting focus. This avoids issues with VoiceOver on iOS
  // causing the page to scroll when moving focus if the element is transitioning
  // from off the screen.
  if (getInteractionModality() === 'virtual') {
    let lastFocusedElement = document.activeElement;
    runAfterTransition(() => {
      // If focus did not move and the element is still in the document, focus it.
      if (document.activeElement === lastFocusedElement && document.contains(element)) {
        focusWithoutScrolling(element);
      }
    });
  } else {
    focusWithoutScrolling(element);
  }
}

const $c9e8f80f5bb1841844f54e4ad30b$var$FocusContext = _react.createContext(null);

let $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = null;
let $c9e8f80f5bb1841844f54e4ad30b$var$scopes = new Set(); // This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:
// https://github.com/reactjs/rfcs/pull/109
// For now, it relies on the DOM tree order rather than the React tree order, and is probably
// less optimized for performance.

/**
 * A FocusScope manages focus for its descendants. It supports containing focus inside
 * the scope, restoring focus to the previously focused element on unmount, and auto
 * focusing children on mount. It also acts as a container for a programmatic focus
 * management interface that can be used to move focus forward and back in response
 * to user events.
 */

export function FocusScope(props) {
  let {
    children,
    contain,
    restoreFocus,
    autoFocus
  } = props;
  let startRef = useRef();
  let endRef = useRef();
  let scopeRef = useRef([]);
  useLayoutEffect(() => {
    // Find all rendered nodes between the sentinels and add them to the scope.
    let node = startRef.current.nextSibling;
    let nodes = [];

    while (node && node !== endRef.current) {
      nodes.push(node);
      node = node.nextSibling;
    }

    scopeRef.current = nodes;
    $c9e8f80f5bb1841844f54e4ad30b$var$scopes.add(scopeRef);
    return () => {
      $c9e8f80f5bb1841844f54e4ad30b$var$scopes.delete(scopeRef);
    };
  }, [children]);
  $c9e8f80f5bb1841844f54e4ad30b$var$useFocusContainment(scopeRef, contain);
  $c9e8f80f5bb1841844f54e4ad30b$var$useRestoreFocus(scopeRef, restoreFocus, contain);
  $c9e8f80f5bb1841844f54e4ad30b$var$useAutoFocus(scopeRef, autoFocus);
  let focusManager = $c9e8f80f5bb1841844f54e4ad30b$var$createFocusManager(scopeRef);
  return /*#__PURE__*/_react.createElement($c9e8f80f5bb1841844f54e4ad30b$var$FocusContext.Provider, {
    value: focusManager
  }, /*#__PURE__*/_react.createElement("span", {
    hidden: true,
    ref: startRef
  }), children, /*#__PURE__*/_react.createElement("span", {
    hidden: true,
    ref: endRef
  }));
}
/**
 * Returns a FocusManager interface for the parent FocusScope.
 * A FocusManager can be used to programmatically move focus within
 * a FocusScope, e.g. in response to user events like keyboard navigation.
 */

export function useFocusManager() {
  return useContext($c9e8f80f5bb1841844f54e4ad30b$var$FocusContext);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$createFocusManager(scopeRef) {
  return {
    focusNext(opts) {
      if (opts === void 0) {
        opts = {};
      }

      let node = opts.from || document.activeElement;
      let focusable = $c9e8f80f5bb1841844f54e4ad30b$var$getFocusableElementsInScope(scopeRef.current, opts);
      let nextNode = focusable.find(n => !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY)));

      if (!nextNode && opts.wrap) {
        nextNode = focusable[0];
      }

      if (nextNode) {
        nextNode.focus();
      }

      return nextNode;
    },

    focusPrevious(opts) {
      if (opts === void 0) {
        opts = {};
      }

      let node = opts.from || document.activeElement;
      let focusable = $c9e8f80f5bb1841844f54e4ad30b$var$getFocusableElementsInScope(scopeRef.current, opts).reverse();
      let previousNode = focusable.find(n => !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY)));

      if (!previousNode && opts.wrap) {
        previousNode = focusable[0];
      }

      if (previousNode) {
        previousNode.focus();
      }

      return previousNode;
    }

  };
}

const $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];
const $c9e8f80f5bb1841844f54e4ad30b$var$FOCUSABLE_ELEMENT_SELECTOR = $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.join(',') + ',[tabindex]';
$c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.push('[tabindex]:not([tabindex="-1"])');
const $c9e8f80f5bb1841844f54e4ad30b$var$TABBABLE_ELEMENT_SELECTOR = $c9e8f80f5bb1841844f54e4ad30b$var$focusableElements.join(':not([tabindex="-1"]),');

function $c9e8f80f5bb1841844f54e4ad30b$var$getFocusableElementsInScope(scope, opts) {
  let res = [];
  let selector = opts.tabbable ? $c9e8f80f5bb1841844f54e4ad30b$var$TABBABLE_ELEMENT_SELECTOR : $c9e8f80f5bb1841844f54e4ad30b$var$FOCUSABLE_ELEMENT_SELECTOR;

  for (let node of scope) {
    if (node.matches(selector)) {
      res.push(node);
    }

    res.push(...Array.from(node.querySelectorAll(selector)));
  }

  return res;
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useFocusContainment(scopeRef, contain) {
  let focusedNode = useRef();
  let raf = useRef(null);
  useEffect(() => {
    let scope = scopeRef.current;

    if (!contain) {
      return;
    } // Handle the Tab key to contain focus within the scope


    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(focusedElement, scope)) {
        return;
      }

      let elements = $c9e8f80f5bb1841844f54e4ad30b$var$getFocusableElementsInScope(scope, {
        tabbable: true
      });
      let position = elements.indexOf(focusedElement);
      let lastPosition = elements.length - 1;
      let nextElement = null;

      if (e.shiftKey) {
        if (position <= 0) {
          nextElement = elements[lastPosition];
        } else {
          nextElement = elements[position - 1];
        }
      } else {
        if (position === lastPosition) {
          nextElement = elements[0];
        } else {
          nextElement = elements[position + 1];
        }
      }

      e.preventDefault();

      if (nextElement) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nextElement, true);
      }
    };

    let onFocus = e => {
      // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),
      // restore focus to the previously focused node or the first tabbable element in the active scope.
      let isInAnyScope = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(e.target, $c9e8f80f5bb1841844f54e4ad30b$var$scopes);

      if (!isInAnyScope) {
        if (focusedNode.current) {
          focusedNode.current.focus();
        } else if ($c9e8f80f5bb1841844f54e4ad30b$var$activeScope) {
          $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope($c9e8f80f5bb1841844f54e4ad30b$var$activeScope.current);
        }
      } else {
        $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;
        focusedNode.current = e.target;
      }
    };

    let onBlur = e => {
      // Firefox doesn't shift focus back to the Dialog properly without this
      raf.current = requestAnimationFrame(() => {
        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
        let isInAnyScope = $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(document.activeElement, $c9e8f80f5bb1841844f54e4ad30b$var$scopes);

        if (!isInAnyScope) {
          $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;
          focusedNode.current = e.target;
          focusedNode.current.focus();
        }
      });
    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('focusin', onFocus, false);
    scope.forEach(element => element.addEventListener('focusin', onFocus, false));
    scope.forEach(element => element.addEventListener('focusout', onBlur, false));
    return () => {
      document.removeEventListener('keydown', onKeyDown, false);
      document.removeEventListener('focusin', onFocus, false);
      scope.forEach(element => element.removeEventListener('focusin', onFocus, false));
      scope.forEach(element => element.removeEventListener('focusout', onBlur, false));
    };
  }, [scopeRef, contain]); // eslint-disable-next-line arrow-body-style

  useEffect(() => {
    return () => cancelAnimationFrame(raf.current);
  }, [raf]);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$isElementInAnyScope(element, scopes) {
  for (let scope of scopes.values()) {
    if ($c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(element, scope.current)) {
      return true;
    }
  }

  return false;
}

function $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(element, scope) {
  return scope.some(node => node.contains(element));
}

function $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(element, scroll) {
  if (scroll === void 0) {
    scroll = false;
  }

  if (element != null && !scroll) {
    try {
      focusSafely(element);
    } catch (err) {// ignore
    }
  } else if (element != null) {
    try {
      element.focus();
    } catch (err) {// ignore
    }
  }
}

function $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope(scope) {
  let elements = $c9e8f80f5bb1841844f54e4ad30b$var$getFocusableElementsInScope(scope, {
    tabbable: true
  });
  $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(elements[0]);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useAutoFocus(scopeRef, autoFocus) {
  useEffect(() => {
    if (autoFocus) {
      $c9e8f80f5bb1841844f54e4ad30b$var$activeScope = scopeRef;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(document.activeElement, $c9e8f80f5bb1841844f54e4ad30b$var$activeScope.current)) {
        $c9e8f80f5bb1841844f54e4ad30b$var$focusFirstInScope(scopeRef.current);
      }
    }
  }, [scopeRef, autoFocus]);
}

function $c9e8f80f5bb1841844f54e4ad30b$var$useRestoreFocus(scopeRef, restoreFocus, contain) {
  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
  useLayoutEffect(() => {
    let scope = scopeRef.current;
    let nodeToRestore = document.activeElement; // Handle the Tab key so that tabbing out of the scope goes to the next element
    // after the node that had focus when the scope mounted. This is important when
    // using portals for overlays, so that focus goes to the expected element when
    // tabbing out of the overlay.

    let onKeyDown = e => {
      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      let focusedElement = document.activeElement;

      if (!$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(focusedElement, scope)) {
        return;
      } // Create a DOM tree walker that matches all tabbable elements


      let walker = getFocusableTreeWalker(document.body, {
        tabbable: true
      }); // Find the next tabbable element after the currently focused element

      walker.currentNode = focusedElement;
      let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode(); // If there is no next element, or it is outside the current scope, move focus to the
      // next element after the node to restore to instead.

      if ((!nextElement || !$c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(nextElement, scope)) && nodeToRestore) {
        walker.currentNode = nodeToRestore; // Skip over elements within the scope, in case the scope immediately follows the node to restore.

        do {
          nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
        } while ($c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(nextElement, scope));

        e.preventDefault();
        e.stopPropagation();

        if (nextElement) {
          nextElement.focus();
        } else {
          // If there is no next element, blur the focused element to move focus to the body.
          focusedElement.blur();
        }
      }
    };

    if (!contain) {
      document.addEventListener('keydown', onKeyDown, true);
    }

    return () => {
      if (!contain) {
        document.removeEventListener('keydown', onKeyDown, true);
      }

      if (restoreFocus && nodeToRestore && $c9e8f80f5bb1841844f54e4ad30b$var$isElementInScope(document.activeElement, scope)) {
        requestAnimationFrame(() => {
          if (document.body.contains(nodeToRestore)) {
            $c9e8f80f5bb1841844f54e4ad30b$var$focusElement(nodeToRestore);
          }
        });
      }
    };
  }, [scopeRef, restoreFocus, contain]);
}
/**
 * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}
 * that matches all focusable/tabbable elements.
 */


export function getFocusableTreeWalker(root, opts) {
  let selector = (opts == null ? void 0 : opts.tabbable) ? $c9e8f80f5bb1841844f54e4ad30b$var$TABBABLE_ELEMENT_SELECTOR : $c9e8f80f5bb1841844f54e4ad30b$var$FOCUSABLE_ELEMENT_SELECTOR;
  let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      var _opts$from;

      // Skip nodes inside the starting node.
      if (opts == null ? void 0 : (_opts$from = opts.from) == null ? void 0 : _opts$from.contains(node)) {
        return NodeFilter.FILTER_REJECT;
      }

      if (node.matches(selector)) {
        return NodeFilter.FILTER_ACCEPT;
      }

      return NodeFilter.FILTER_SKIP;
    }

  }, false);

  if (opts == null ? void 0 : opts.from) {
    walker.currentNode = opts.from;
  }

  return walker;
}

/**
 * Determines whether a focus ring should be shown to indicate keyboard focus.
 * Focus rings are visible only when the user is interacting with a keyboard,
 * not with a mouse, touch, or other input methods.
 */
export function useFocusRing(props) {
  if (props === void 0) {
    props = {};
  }

  let {
    within
  } = props;
  let [isFocused, setFocused] = useState(false);
  let [isFocusWithin, setFocusWithin] = useState(false);
  let {
    isFocusVisible
  } = useFocusVisible(props);
  let {
    focusProps
  } = useFocus({
    isDisabled: within,
    onFocusChange: setFocused
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !within,
    onFocusWithinChange: setFocusWithin
  });
  return {
    isFocused: within ? isFocusWithin : isFocused,
    isFocusVisible: (within ? isFocusWithin : isFocused) && isFocusVisible,
    focusProps: within ? focusWithinProps : focusProps
  };
}

/**
 * A utility component that applies a CSS class when an element has keyboard focus.
 * Focus rings are visible only when the user is interacting with a keyboard,
 * not with a mouse, touch, or other input methods.
 */
export function FocusRing(props) {
  let {
    children,
    focusClass,
    focusRingClass
  } = props;
  let {
    isFocused,
    isFocusVisible,
    focusProps
  } = useFocusRing(props);

  let child = _react.Children.only(children);

  return _react.cloneElement(child, mergeProps(child.props, _babelRuntimeHelpersEsmExtends({}, focusProps, {
    className: _clsx({
      [focusClass || '']: isFocused,
      [focusRingClass || '']: isFocusVisible
    })
  })));
}

let $e11539c8317b2d21639df611cb5658f$var$FocusableContext = _react.createContext(null);

function $e11539c8317b2d21639df611cb5658f$var$useFocusableContext(ref) {
  let context = useContext($e11539c8317b2d21639df611cb5658f$var$FocusableContext) || {};
  useEffect(() => {
    if (context && context.ref) {
      context.ref.current = ref.current;
      return () => {
        context.ref.current = null;
      };
    }
  }, [context, ref]);
  return context;
}
/**
 * Provides DOM props to the nearest focusable child.
 */


function $e11539c8317b2d21639df611cb5658f$var$FocusableProvider(props, ref) {
  let {
    children
  } = props,
      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, ["children"]);

  let context = _babelRuntimeHelpersEsmExtends({}, otherProps, {
    ref
  });

  return /*#__PURE__*/_react.createElement($e11539c8317b2d21639df611cb5658f$var$FocusableContext.Provider, {
    value: context
  }, children);
}

export let FocusableProvider = _react.forwardRef($e11539c8317b2d21639df611cb5658f$var$FocusableProvider);

/**
 * Used to make an element focusable and capable of auto focus.
 */
export function useFocusable(props, domRef) {
  let {
    focusProps
  } = useFocus(props);
  let {
    keyboardProps
  } = useKeyboard(props);
  let interactions = mergeProps(focusProps, keyboardProps);
  let domProps = $e11539c8317b2d21639df611cb5658f$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  useEffect(() => {
    if (props.autoFocus && domRef.current) {
      domRef.current.focus();
    }
  }, [props.autoFocus, domRef]);
  return {
    focusableProps: mergeProps(_babelRuntimeHelpersEsmExtends({}, interactions, {
      tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined
    }), interactionProps)
  };
}
//# sourceMappingURL=module.js.map
